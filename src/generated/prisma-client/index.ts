// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  author: (where?: AuthorWhereInput) => Promise<boolean>;
  book: (where?: BookWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  display: (where?: DisplayWhereInput) => Promise<boolean>;
  gerne: (where?: GerneWhereInput) => Promise<boolean>;
  profile: (where?: ProfileWhereInput) => Promise<boolean>;
  quote: (where?: QuoteWhereInput) => Promise<boolean>;
  shelf: (where?: ShelfWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  author: (where: AuthorWhereUniqueInput) => AuthorNullablePromise;
  authors: (args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Author>;
  authorsConnection: (args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AuthorConnectionPromise;
  book: (where: BookWhereUniqueInput) => BookNullablePromise;
  books: (args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Book>;
  booksConnection: (args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BookConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  display: (where: DisplayWhereUniqueInput) => DisplayNullablePromise;
  displays: (args?: {
    where?: DisplayWhereInput;
    orderBy?: DisplayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Display>;
  displaysConnection: (args?: {
    where?: DisplayWhereInput;
    orderBy?: DisplayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DisplayConnectionPromise;
  gerne: (where: GerneWhereUniqueInput) => GerneNullablePromise;
  gernes: (args?: {
    where?: GerneWhereInput;
    orderBy?: GerneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Gerne>;
  gernesConnection: (args?: {
    where?: GerneWhereInput;
    orderBy?: GerneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GerneConnectionPromise;
  profile: (where: ProfileWhereUniqueInput) => ProfileNullablePromise;
  profiles: (args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Profile>;
  profilesConnection: (args?: {
    where?: ProfileWhereInput;
    orderBy?: ProfileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProfileConnectionPromise;
  quote: (where: QuoteWhereUniqueInput) => QuoteNullablePromise;
  quotes: (args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Quote>;
  quotesConnection: (args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuoteConnectionPromise;
  shelf: (where: ShelfWhereUniqueInput) => ShelfNullablePromise;
  shelves: (args?: {
    where?: ShelfWhereInput;
    orderBy?: ShelfOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Shelf>;
  shelvesConnection: (args?: {
    where?: ShelfWhereInput;
    orderBy?: ShelfOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ShelfConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagNullablePromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAuthor: (data: AuthorCreateInput) => AuthorPromise;
  updateAuthor: (args: {
    data: AuthorUpdateInput;
    where: AuthorWhereUniqueInput;
  }) => AuthorPromise;
  updateManyAuthors: (args: {
    data: AuthorUpdateManyMutationInput;
    where?: AuthorWhereInput;
  }) => BatchPayloadPromise;
  upsertAuthor: (args: {
    where: AuthorWhereUniqueInput;
    create: AuthorCreateInput;
    update: AuthorUpdateInput;
  }) => AuthorPromise;
  deleteAuthor: (where: AuthorWhereUniqueInput) => AuthorPromise;
  deleteManyAuthors: (where?: AuthorWhereInput) => BatchPayloadPromise;
  createBook: (data: BookCreateInput) => BookPromise;
  updateBook: (args: {
    data: BookUpdateInput;
    where: BookWhereUniqueInput;
  }) => BookPromise;
  updateManyBooks: (args: {
    data: BookUpdateManyMutationInput;
    where?: BookWhereInput;
  }) => BatchPayloadPromise;
  upsertBook: (args: {
    where: BookWhereUniqueInput;
    create: BookCreateInput;
    update: BookUpdateInput;
  }) => BookPromise;
  deleteBook: (where: BookWhereUniqueInput) => BookPromise;
  deleteManyBooks: (where?: BookWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createDisplay: (data: DisplayCreateInput) => DisplayPromise;
  updateDisplay: (args: {
    data: DisplayUpdateInput;
    where: DisplayWhereUniqueInput;
  }) => DisplayPromise;
  upsertDisplay: (args: {
    where: DisplayWhereUniqueInput;
    create: DisplayCreateInput;
    update: DisplayUpdateInput;
  }) => DisplayPromise;
  deleteDisplay: (where: DisplayWhereUniqueInput) => DisplayPromise;
  deleteManyDisplays: (where?: DisplayWhereInput) => BatchPayloadPromise;
  createGerne: (data: GerneCreateInput) => GernePromise;
  updateGerne: (args: {
    data: GerneUpdateInput;
    where: GerneWhereUniqueInput;
  }) => GernePromise;
  updateManyGernes: (args: {
    data: GerneUpdateManyMutationInput;
    where?: GerneWhereInput;
  }) => BatchPayloadPromise;
  upsertGerne: (args: {
    where: GerneWhereUniqueInput;
    create: GerneCreateInput;
    update: GerneUpdateInput;
  }) => GernePromise;
  deleteGerne: (where: GerneWhereUniqueInput) => GernePromise;
  deleteManyGernes: (where?: GerneWhereInput) => BatchPayloadPromise;
  createProfile: (data: ProfileCreateInput) => ProfilePromise;
  updateProfile: (args: {
    data: ProfileUpdateInput;
    where: ProfileWhereUniqueInput;
  }) => ProfilePromise;
  updateManyProfiles: (args: {
    data: ProfileUpdateManyMutationInput;
    where?: ProfileWhereInput;
  }) => BatchPayloadPromise;
  upsertProfile: (args: {
    where: ProfileWhereUniqueInput;
    create: ProfileCreateInput;
    update: ProfileUpdateInput;
  }) => ProfilePromise;
  deleteProfile: (where: ProfileWhereUniqueInput) => ProfilePromise;
  deleteManyProfiles: (where?: ProfileWhereInput) => BatchPayloadPromise;
  createQuote: (data: QuoteCreateInput) => QuotePromise;
  updateQuote: (args: {
    data: QuoteUpdateInput;
    where: QuoteWhereUniqueInput;
  }) => QuotePromise;
  updateManyQuotes: (args: {
    data: QuoteUpdateManyMutationInput;
    where?: QuoteWhereInput;
  }) => BatchPayloadPromise;
  upsertQuote: (args: {
    where: QuoteWhereUniqueInput;
    create: QuoteCreateInput;
    update: QuoteUpdateInput;
  }) => QuotePromise;
  deleteQuote: (where: QuoteWhereUniqueInput) => QuotePromise;
  deleteManyQuotes: (where?: QuoteWhereInput) => BatchPayloadPromise;
  createShelf: (data: ShelfCreateInput) => ShelfPromise;
  updateShelf: (args: {
    data: ShelfUpdateInput;
    where: ShelfWhereUniqueInput;
  }) => ShelfPromise;
  updateManyShelves: (args: {
    data: ShelfUpdateManyMutationInput;
    where?: ShelfWhereInput;
  }) => BatchPayloadPromise;
  upsertShelf: (args: {
    where: ShelfWhereUniqueInput;
    create: ShelfCreateInput;
    update: ShelfUpdateInput;
  }) => ShelfPromise;
  deleteShelf: (where: ShelfWhereUniqueInput) => ShelfPromise;
  deleteManyShelves: (where?: ShelfWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  author: (
    where?: AuthorSubscriptionWhereInput
  ) => AuthorSubscriptionPayloadSubscription;
  book: (
    where?: BookSubscriptionWhereInput
  ) => BookSubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  display: (
    where?: DisplaySubscriptionWhereInput
  ) => DisplaySubscriptionPayloadSubscription;
  gerne: (
    where?: GerneSubscriptionWhereInput
  ) => GerneSubscriptionPayloadSubscription;
  profile: (
    where?: ProfileSubscriptionWhereInput
  ) => ProfileSubscriptionPayloadSubscription;
  quote: (
    where?: QuoteSubscriptionWhereInput
  ) => QuoteSubscriptionPayloadSubscription;
  shelf: (
    where?: ShelfSubscriptionWhereInput
  ) => ShelfSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Gender = "MALE" | "FEMALE";

export type GerneOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "term_ASC"
  | "term_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BookOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "covorImage_ASC"
  | "covorImage_DESC"
  | "description_ASC"
  | "description_DESC"
  | "ISBN_ASC"
  | "ISBN_DESC"
  | "wantCount_ASC"
  | "wantCount_DESC"
  | "readingCount_ASC"
  | "readingCount_DESC"
  | "readCount_ASC"
  | "readCount_DESC"
  | "avgRating_ASC"
  | "avgRating_DESC"
  | "pages_ASC"
  | "pages_DESC"
  | "avgRatings_ASC"
  | "avgRatings_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ShelfOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DisplayOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type QuoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "term_ASC"
  | "term_DESC"
  | "likesCount_ASC"
  | "likesCount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "term_ASC"
  | "term_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AuthorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "Born_ASC"
  | "Born_DESC"
  | "Died_ASC"
  | "Died_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProfileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "age_ASC"
  | "age_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "interests_ASC"
  | "interests_DESC"
  | "favoriteBook_ASC"
  | "favoriteBook_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "username_ASC"
  | "username_DESC"
  | "isAdmin_ASC"
  | "isAdmin_DESC"
  | "bookAvgRating_ASC"
  | "bookAvgRating_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AuthorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface GerneWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  term?: Maybe<String>;
  term_not?: Maybe<String>;
  term_in?: Maybe<String[] | String>;
  term_not_in?: Maybe<String[] | String>;
  term_lt?: Maybe<String>;
  term_lte?: Maybe<String>;
  term_gt?: Maybe<String>;
  term_gte?: Maybe<String>;
  term_contains?: Maybe<String>;
  term_not_contains?: Maybe<String>;
  term_starts_with?: Maybe<String>;
  term_not_starts_with?: Maybe<String>;
  term_ends_with?: Maybe<String>;
  term_not_ends_with?: Maybe<String>;
  books_every?: Maybe<BookWhereInput>;
  books_some?: Maybe<BookWhereInput>;
  books_none?: Maybe<BookWhereInput>;
  authors_every?: Maybe<AuthorWhereInput>;
  authors_some?: Maybe<AuthorWhereInput>;
  authors_none?: Maybe<AuthorWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<GerneWhereInput[] | GerneWhereInput>;
  OR?: Maybe<GerneWhereInput[] | GerneWhereInput>;
  NOT?: Maybe<GerneWhereInput[] | GerneWhereInput>;
}

export interface BookWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  author?: Maybe<AuthorWhereInput>;
  gernes_every?: Maybe<GerneWhereInput>;
  gernes_some?: Maybe<GerneWhereInput>;
  gernes_none?: Maybe<GerneWhereInput>;
  covorImage?: Maybe<String>;
  covorImage_not?: Maybe<String>;
  covorImage_in?: Maybe<String[] | String>;
  covorImage_not_in?: Maybe<String[] | String>;
  covorImage_lt?: Maybe<String>;
  covorImage_lte?: Maybe<String>;
  covorImage_gt?: Maybe<String>;
  covorImage_gte?: Maybe<String>;
  covorImage_contains?: Maybe<String>;
  covorImage_not_contains?: Maybe<String>;
  covorImage_starts_with?: Maybe<String>;
  covorImage_not_starts_with?: Maybe<String>;
  covorImage_ends_with?: Maybe<String>;
  covorImage_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  ISBN?: Maybe<String>;
  ISBN_not?: Maybe<String>;
  ISBN_in?: Maybe<String[] | String>;
  ISBN_not_in?: Maybe<String[] | String>;
  ISBN_lt?: Maybe<String>;
  ISBN_lte?: Maybe<String>;
  ISBN_gt?: Maybe<String>;
  ISBN_gte?: Maybe<String>;
  ISBN_contains?: Maybe<String>;
  ISBN_not_contains?: Maybe<String>;
  ISBN_starts_with?: Maybe<String>;
  ISBN_not_starts_with?: Maybe<String>;
  ISBN_ends_with?: Maybe<String>;
  ISBN_not_ends_with?: Maybe<String>;
  wantCount?: Maybe<Int>;
  wantCount_not?: Maybe<Int>;
  wantCount_in?: Maybe<Int[] | Int>;
  wantCount_not_in?: Maybe<Int[] | Int>;
  wantCount_lt?: Maybe<Int>;
  wantCount_lte?: Maybe<Int>;
  wantCount_gt?: Maybe<Int>;
  wantCount_gte?: Maybe<Int>;
  readingCount?: Maybe<Int>;
  readingCount_not?: Maybe<Int>;
  readingCount_in?: Maybe<Int[] | Int>;
  readingCount_not_in?: Maybe<Int[] | Int>;
  readingCount_lt?: Maybe<Int>;
  readingCount_lte?: Maybe<Int>;
  readingCount_gt?: Maybe<Int>;
  readingCount_gte?: Maybe<Int>;
  readCount?: Maybe<Int>;
  readCount_not?: Maybe<Int>;
  readCount_in?: Maybe<Int[] | Int>;
  readCount_not_in?: Maybe<Int[] | Int>;
  readCount_lt?: Maybe<Int>;
  readCount_lte?: Maybe<Int>;
  readCount_gt?: Maybe<Int>;
  readCount_gte?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  avgRating_not?: Maybe<Float>;
  avgRating_in?: Maybe<Float[] | Float>;
  avgRating_not_in?: Maybe<Float[] | Float>;
  avgRating_lt?: Maybe<Float>;
  avgRating_lte?: Maybe<Float>;
  avgRating_gt?: Maybe<Float>;
  avgRating_gte?: Maybe<Float>;
  pages?: Maybe<Int>;
  pages_not?: Maybe<Int>;
  pages_in?: Maybe<Int[] | Int>;
  pages_not_in?: Maybe<Int[] | Int>;
  pages_lt?: Maybe<Int>;
  pages_lte?: Maybe<Int>;
  pages_gt?: Maybe<Int>;
  pages_gte?: Maybe<Int>;
  avgRatings?: Maybe<Int>;
  avgRatings_not?: Maybe<Int>;
  avgRatings_in?: Maybe<Int[] | Int>;
  avgRatings_not_in?: Maybe<Int[] | Int>;
  avgRatings_lt?: Maybe<Int>;
  avgRatings_lte?: Maybe<Int>;
  avgRatings_gt?: Maybe<Int>;
  avgRatings_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BookWhereInput[] | BookWhereInput>;
  OR?: Maybe<BookWhereInput[] | BookWhereInput>;
  NOT?: Maybe<BookWhereInput[] | BookWhereInput>;
}

export interface AuthorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  Born?: Maybe<DateTimeInput>;
  Born_not?: Maybe<DateTimeInput>;
  Born_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  Born_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  Born_lt?: Maybe<DateTimeInput>;
  Born_lte?: Maybe<DateTimeInput>;
  Born_gt?: Maybe<DateTimeInput>;
  Born_gte?: Maybe<DateTimeInput>;
  Died?: Maybe<DateTimeInput>;
  Died_not?: Maybe<DateTimeInput>;
  Died_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  Died_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  Died_lt?: Maybe<DateTimeInput>;
  Died_lte?: Maybe<DateTimeInput>;
  Died_gt?: Maybe<DateTimeInput>;
  Died_gte?: Maybe<DateTimeInput>;
  gernes_every?: Maybe<GerneWhereInput>;
  gernes_some?: Maybe<GerneWhereInput>;
  gernes_none?: Maybe<GerneWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  books_every?: Maybe<BookWhereInput>;
  books_some?: Maybe<BookWhereInput>;
  books_none?: Maybe<BookWhereInput>;
  Quotes_every?: Maybe<QuoteWhereInput>;
  Quotes_some?: Maybe<QuoteWhereInput>;
  Quotes_none?: Maybe<QuoteWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AuthorWhereInput[] | AuthorWhereInput>;
  OR?: Maybe<AuthorWhereInput[] | AuthorWhereInput>;
  NOT?: Maybe<AuthorWhereInput[] | AuthorWhereInput>;
}

export interface QuoteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  term?: Maybe<String>;
  term_not?: Maybe<String>;
  term_in?: Maybe<String[] | String>;
  term_not_in?: Maybe<String[] | String>;
  term_lt?: Maybe<String>;
  term_lte?: Maybe<String>;
  term_gt?: Maybe<String>;
  term_gte?: Maybe<String>;
  term_contains?: Maybe<String>;
  term_not_contains?: Maybe<String>;
  term_starts_with?: Maybe<String>;
  term_not_starts_with?: Maybe<String>;
  term_ends_with?: Maybe<String>;
  term_not_ends_with?: Maybe<String>;
  author?: Maybe<AuthorWhereInput>;
  tags_every?: Maybe<TagWhereInput>;
  tags_some?: Maybe<TagWhereInput>;
  tags_none?: Maybe<TagWhereInput>;
  likesCount?: Maybe<Int>;
  likesCount_not?: Maybe<Int>;
  likesCount_in?: Maybe<Int[] | Int>;
  likesCount_not_in?: Maybe<Int[] | Int>;
  likesCount_lt?: Maybe<Int>;
  likesCount_lte?: Maybe<Int>;
  likesCount_gt?: Maybe<Int>;
  likesCount_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<QuoteWhereInput[] | QuoteWhereInput>;
  OR?: Maybe<QuoteWhereInput[] | QuoteWhereInput>;
  NOT?: Maybe<QuoteWhereInput[] | QuoteWhereInput>;
}

export interface TagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  quotes_every?: Maybe<QuoteWhereInput>;
  quotes_some?: Maybe<QuoteWhereInput>;
  quotes_none?: Maybe<QuoteWhereInput>;
  term?: Maybe<String>;
  term_not?: Maybe<String>;
  term_in?: Maybe<String[] | String>;
  term_not_in?: Maybe<String[] | String>;
  term_lt?: Maybe<String>;
  term_lte?: Maybe<String>;
  term_gt?: Maybe<String>;
  term_gte?: Maybe<String>;
  term_contains?: Maybe<String>;
  term_not_contains?: Maybe<String>;
  term_starts_with?: Maybe<String>;
  term_not_starts_with?: Maybe<String>;
  term_ends_with?: Maybe<String>;
  term_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TagWhereInput[] | TagWhereInput>;
  OR?: Maybe<TagWhereInput[] | TagWhereInput>;
  NOT?: Maybe<TagWhereInput[] | TagWhereInput>;
}

export interface CommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  Book?: Maybe<BookWhereInput>;
  user?: Maybe<UserWhereInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  profile?: Maybe<ProfileWhereInput>;
  isAdmin?: Maybe<Boolean>;
  isAdmin_not?: Maybe<Boolean>;
  RatingBooks_every?: Maybe<BookWhereInput>;
  RatingBooks_some?: Maybe<BookWhereInput>;
  RatingBooks_none?: Maybe<BookWhereInput>;
  bookAvgRating?: Maybe<Float>;
  bookAvgRating_not?: Maybe<Float>;
  bookAvgRating_in?: Maybe<Float[] | Float>;
  bookAvgRating_not_in?: Maybe<Float[] | Float>;
  bookAvgRating_lt?: Maybe<Float>;
  bookAvgRating_lte?: Maybe<Float>;
  bookAvgRating_gt?: Maybe<Float>;
  bookAvgRating_gte?: Maybe<Float>;
  bookComments_every?: Maybe<CommentWhereInput>;
  bookComments_some?: Maybe<CommentWhereInput>;
  bookComments_none?: Maybe<CommentWhereInput>;
  shelves_every?: Maybe<ShelfWhereInput>;
  shelves_some?: Maybe<ShelfWhereInput>;
  shelves_none?: Maybe<ShelfWhereInput>;
  likeQuotes_every?: Maybe<QuoteWhereInput>;
  likeQuotes_some?: Maybe<QuoteWhereInput>;
  likeQuotes_none?: Maybe<QuoteWhereInput>;
  displays_every?: Maybe<DisplayWhereInput>;
  displays_some?: Maybe<DisplayWhereInput>;
  displays_none?: Maybe<DisplayWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ProfileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  age?: Maybe<Int>;
  age_not?: Maybe<Int>;
  age_in?: Maybe<Int[] | Int>;
  age_not_in?: Maybe<Int[] | Int>;
  age_lt?: Maybe<Int>;
  age_lte?: Maybe<Int>;
  age_gt?: Maybe<Int>;
  age_gte?: Maybe<Int>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  interests?: Maybe<String>;
  interests_not?: Maybe<String>;
  interests_in?: Maybe<String[] | String>;
  interests_not_in?: Maybe<String[] | String>;
  interests_lt?: Maybe<String>;
  interests_lte?: Maybe<String>;
  interests_gt?: Maybe<String>;
  interests_gte?: Maybe<String>;
  interests_contains?: Maybe<String>;
  interests_not_contains?: Maybe<String>;
  interests_starts_with?: Maybe<String>;
  interests_not_starts_with?: Maybe<String>;
  interests_ends_with?: Maybe<String>;
  interests_not_ends_with?: Maybe<String>;
  favoriteBook?: Maybe<String>;
  favoriteBook_not?: Maybe<String>;
  favoriteBook_in?: Maybe<String[] | String>;
  favoriteBook_not_in?: Maybe<String[] | String>;
  favoriteBook_lt?: Maybe<String>;
  favoriteBook_lte?: Maybe<String>;
  favoriteBook_gt?: Maybe<String>;
  favoriteBook_gte?: Maybe<String>;
  favoriteBook_contains?: Maybe<String>;
  favoriteBook_not_contains?: Maybe<String>;
  favoriteBook_starts_with?: Maybe<String>;
  favoriteBook_not_starts_with?: Maybe<String>;
  favoriteBook_ends_with?: Maybe<String>;
  favoriteBook_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProfileWhereInput[] | ProfileWhereInput>;
  OR?: Maybe<ProfileWhereInput[] | ProfileWhereInput>;
  NOT?: Maybe<ProfileWhereInput[] | ProfileWhereInput>;
}

export interface ShelfWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  displays_every?: Maybe<DisplayWhereInput>;
  displays_some?: Maybe<DisplayWhereInput>;
  displays_none?: Maybe<DisplayWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ShelfWhereInput[] | ShelfWhereInput>;
  OR?: Maybe<ShelfWhereInput[] | ShelfWhereInput>;
  NOT?: Maybe<ShelfWhereInput[] | ShelfWhereInput>;
}

export interface DisplayWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  book?: Maybe<BookWhereInput>;
  shelves_every?: Maybe<ShelfWhereInput>;
  shelves_some?: Maybe<ShelfWhereInput>;
  shelves_none?: Maybe<ShelfWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DisplayWhereInput[] | DisplayWhereInput>;
  OR?: Maybe<DisplayWhereInput[] | DisplayWhereInput>;
  NOT?: Maybe<DisplayWhereInput[] | DisplayWhereInput>;
}

export type BookWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  ISBN?: Maybe<String>;
}>;

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type DisplayWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type GerneWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  term?: Maybe<String>;
}>;

export type ProfileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QuoteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  term?: Maybe<String>;
}>;

export type ShelfWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  term?: Maybe<String>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  username?: Maybe<String>;
}>;

export interface AuthorCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  Born?: Maybe<DateTimeInput>;
  Died?: Maybe<DateTimeInput>;
  gernes?: Maybe<GerneCreateManyWithoutAuthorsInput>;
  description?: Maybe<String>;
  photos?: Maybe<AuthorCreatephotosInput>;
  books?: Maybe<BookCreateManyWithoutAuthorInput>;
  Quotes?: Maybe<QuoteCreateManyWithoutAuthorInput>;
}

export interface GerneCreateManyWithoutAuthorsInput {
  create?: Maybe<
    GerneCreateWithoutAuthorsInput[] | GerneCreateWithoutAuthorsInput
  >;
  connect?: Maybe<GerneWhereUniqueInput[] | GerneWhereUniqueInput>;
}

export interface GerneCreateWithoutAuthorsInput {
  id?: Maybe<ID_Input>;
  term: String;
  books?: Maybe<BookCreateManyWithoutGernesInput>;
}

export interface BookCreateManyWithoutGernesInput {
  create?: Maybe<BookCreateWithoutGernesInput[] | BookCreateWithoutGernesInput>;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
}

export interface BookCreateWithoutGernesInput {
  id?: Maybe<ID_Input>;
  title: String;
  author: AuthorCreateOneWithoutBooksInput;
  covorImage: String;
  description: String;
  comments?: Maybe<CommentCreateManyWithoutBookInput>;
  ISBN: String;
  wantCount: Int;
  readingCount: Int;
  readCount: Int;
  avgRating: Float;
  pages?: Maybe<Int>;
  avgRatings?: Maybe<Int>;
}

export interface AuthorCreateOneWithoutBooksInput {
  create?: Maybe<AuthorCreateWithoutBooksInput>;
  connect?: Maybe<AuthorWhereUniqueInput>;
}

export interface AuthorCreateWithoutBooksInput {
  id?: Maybe<ID_Input>;
  name: String;
  Born?: Maybe<DateTimeInput>;
  Died?: Maybe<DateTimeInput>;
  gernes?: Maybe<GerneCreateManyWithoutAuthorsInput>;
  description?: Maybe<String>;
  photos?: Maybe<AuthorCreatephotosInput>;
  Quotes?: Maybe<QuoteCreateManyWithoutAuthorInput>;
}

export interface AuthorCreatephotosInput {
  set?: Maybe<String[] | String>;
}

export interface QuoteCreateManyWithoutAuthorInput {
  create?: Maybe<
    QuoteCreateWithoutAuthorInput[] | QuoteCreateWithoutAuthorInput
  >;
  connect?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
}

export interface QuoteCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  term?: Maybe<String>;
  tags?: Maybe<TagCreateManyWithoutQuotesInput>;
  likesCount?: Maybe<Int>;
}

export interface TagCreateManyWithoutQuotesInput {
  create?: Maybe<TagCreateWithoutQuotesInput[] | TagCreateWithoutQuotesInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
}

export interface TagCreateWithoutQuotesInput {
  id?: Maybe<ID_Input>;
  term: String;
}

export interface CommentCreateManyWithoutBookInput {
  create?: Maybe<
    CommentCreateWithoutBookInput[] | CommentCreateWithoutBookInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutBookInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutBookCommentsInput>;
  text: String;
}

export interface UserCreateOneWithoutBookCommentsInput {
  create?: Maybe<UserCreateWithoutBookCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutBookCommentsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  username: String;
  profile?: Maybe<ProfileCreateOneWithoutUserInput>;
  isAdmin?: Maybe<Boolean>;
  RatingBooks?: Maybe<BookCreateManyInput>;
  bookAvgRating?: Maybe<Float>;
  shelves?: Maybe<ShelfCreateManyWithoutUserInput>;
  likeQuotes?: Maybe<QuoteCreateManyInput>;
  displays?: Maybe<DisplayCreateManyWithoutUserInput>;
}

export interface ProfileCreateOneWithoutUserInput {
  create?: Maybe<ProfileCreateWithoutUserInput>;
  connect?: Maybe<ProfileWhereUniqueInput>;
}

export interface ProfileCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  age?: Maybe<Int>;
  gender: Gender;
  bio?: Maybe<String>;
  interests?: Maybe<String>;
  favoriteBook?: Maybe<String>;
}

export interface BookCreateManyInput {
  create?: Maybe<BookCreateInput[] | BookCreateInput>;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
}

export interface BookCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  author: AuthorCreateOneWithoutBooksInput;
  gernes?: Maybe<GerneCreateManyWithoutBooksInput>;
  covorImage: String;
  description: String;
  comments?: Maybe<CommentCreateManyWithoutBookInput>;
  ISBN: String;
  wantCount: Int;
  readingCount: Int;
  readCount: Int;
  avgRating: Float;
  pages?: Maybe<Int>;
  avgRatings?: Maybe<Int>;
}

export interface GerneCreateManyWithoutBooksInput {
  create?: Maybe<GerneCreateWithoutBooksInput[] | GerneCreateWithoutBooksInput>;
  connect?: Maybe<GerneWhereUniqueInput[] | GerneWhereUniqueInput>;
}

export interface GerneCreateWithoutBooksInput {
  id?: Maybe<ID_Input>;
  term: String;
  authors?: Maybe<AuthorCreateManyWithoutGernesInput>;
}

export interface AuthorCreateManyWithoutGernesInput {
  create?: Maybe<
    AuthorCreateWithoutGernesInput[] | AuthorCreateWithoutGernesInput
  >;
  connect?: Maybe<AuthorWhereUniqueInput[] | AuthorWhereUniqueInput>;
}

export interface AuthorCreateWithoutGernesInput {
  id?: Maybe<ID_Input>;
  name: String;
  Born?: Maybe<DateTimeInput>;
  Died?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  photos?: Maybe<AuthorCreatephotosInput>;
  books?: Maybe<BookCreateManyWithoutAuthorInput>;
  Quotes?: Maybe<QuoteCreateManyWithoutAuthorInput>;
}

export interface BookCreateManyWithoutAuthorInput {
  create?: Maybe<BookCreateWithoutAuthorInput[] | BookCreateWithoutAuthorInput>;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
}

export interface BookCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  title: String;
  gernes?: Maybe<GerneCreateManyWithoutBooksInput>;
  covorImage: String;
  description: String;
  comments?: Maybe<CommentCreateManyWithoutBookInput>;
  ISBN: String;
  wantCount: Int;
  readingCount: Int;
  readCount: Int;
  avgRating: Float;
  pages?: Maybe<Int>;
  avgRatings?: Maybe<Int>;
}

export interface ShelfCreateManyWithoutUserInput {
  create?: Maybe<ShelfCreateWithoutUserInput[] | ShelfCreateWithoutUserInput>;
  connect?: Maybe<ShelfWhereUniqueInput[] | ShelfWhereUniqueInput>;
}

export interface ShelfCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  name: String;
  displays?: Maybe<DisplayCreateManyWithoutShelvesInput>;
}

export interface DisplayCreateManyWithoutShelvesInput {
  create?: Maybe<
    DisplayCreateWithoutShelvesInput[] | DisplayCreateWithoutShelvesInput
  >;
  connect?: Maybe<DisplayWhereUniqueInput[] | DisplayWhereUniqueInput>;
}

export interface DisplayCreateWithoutShelvesInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutDisplaysInput>;
  book?: Maybe<BookCreateOneInput>;
}

export interface UserCreateOneWithoutDisplaysInput {
  create?: Maybe<UserCreateWithoutDisplaysInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutDisplaysInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  username: String;
  profile?: Maybe<ProfileCreateOneWithoutUserInput>;
  isAdmin?: Maybe<Boolean>;
  RatingBooks?: Maybe<BookCreateManyInput>;
  bookAvgRating?: Maybe<Float>;
  bookComments?: Maybe<CommentCreateManyWithoutUserInput>;
  shelves?: Maybe<ShelfCreateManyWithoutUserInput>;
  likeQuotes?: Maybe<QuoteCreateManyInput>;
}

export interface CommentCreateManyWithoutUserInput {
  create?: Maybe<
    CommentCreateWithoutUserInput[] | CommentCreateWithoutUserInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  Book?: Maybe<BookCreateOneWithoutCommentsInput>;
  text: String;
}

export interface BookCreateOneWithoutCommentsInput {
  create?: Maybe<BookCreateWithoutCommentsInput>;
  connect?: Maybe<BookWhereUniqueInput>;
}

export interface BookCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  title: String;
  author: AuthorCreateOneWithoutBooksInput;
  gernes?: Maybe<GerneCreateManyWithoutBooksInput>;
  covorImage: String;
  description: String;
  ISBN: String;
  wantCount: Int;
  readingCount: Int;
  readCount: Int;
  avgRating: Float;
  pages?: Maybe<Int>;
  avgRatings?: Maybe<Int>;
}

export interface QuoteCreateManyInput {
  create?: Maybe<QuoteCreateInput[] | QuoteCreateInput>;
  connect?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
}

export interface QuoteCreateInput {
  id?: Maybe<ID_Input>;
  term?: Maybe<String>;
  author?: Maybe<AuthorCreateOneWithoutQuotesInput>;
  tags?: Maybe<TagCreateManyWithoutQuotesInput>;
  likesCount?: Maybe<Int>;
}

export interface AuthorCreateOneWithoutQuotesInput {
  create?: Maybe<AuthorCreateWithoutQuotesInput>;
  connect?: Maybe<AuthorWhereUniqueInput>;
}

export interface AuthorCreateWithoutQuotesInput {
  id?: Maybe<ID_Input>;
  name: String;
  Born?: Maybe<DateTimeInput>;
  Died?: Maybe<DateTimeInput>;
  gernes?: Maybe<GerneCreateManyWithoutAuthorsInput>;
  description?: Maybe<String>;
  photos?: Maybe<AuthorCreatephotosInput>;
  books?: Maybe<BookCreateManyWithoutAuthorInput>;
}

export interface BookCreateOneInput {
  create?: Maybe<BookCreateInput>;
  connect?: Maybe<BookWhereUniqueInput>;
}

export interface DisplayCreateManyWithoutUserInput {
  create?: Maybe<
    DisplayCreateWithoutUserInput[] | DisplayCreateWithoutUserInput
  >;
  connect?: Maybe<DisplayWhereUniqueInput[] | DisplayWhereUniqueInput>;
}

export interface DisplayCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  book?: Maybe<BookCreateOneInput>;
  shelves?: Maybe<ShelfCreateManyWithoutDisplaysInput>;
}

export interface ShelfCreateManyWithoutDisplaysInput {
  create?: Maybe<
    ShelfCreateWithoutDisplaysInput[] | ShelfCreateWithoutDisplaysInput
  >;
  connect?: Maybe<ShelfWhereUniqueInput[] | ShelfWhereUniqueInput>;
}

export interface ShelfCreateWithoutDisplaysInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutShelvesInput>;
  name: String;
}

export interface UserCreateOneWithoutShelvesInput {
  create?: Maybe<UserCreateWithoutShelvesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutShelvesInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  username: String;
  profile?: Maybe<ProfileCreateOneWithoutUserInput>;
  isAdmin?: Maybe<Boolean>;
  RatingBooks?: Maybe<BookCreateManyInput>;
  bookAvgRating?: Maybe<Float>;
  bookComments?: Maybe<CommentCreateManyWithoutUserInput>;
  likeQuotes?: Maybe<QuoteCreateManyInput>;
  displays?: Maybe<DisplayCreateManyWithoutUserInput>;
}

export interface AuthorUpdateInput {
  name?: Maybe<String>;
  Born?: Maybe<DateTimeInput>;
  Died?: Maybe<DateTimeInput>;
  gernes?: Maybe<GerneUpdateManyWithoutAuthorsInput>;
  description?: Maybe<String>;
  photos?: Maybe<AuthorUpdatephotosInput>;
  books?: Maybe<BookUpdateManyWithoutAuthorInput>;
  Quotes?: Maybe<QuoteUpdateManyWithoutAuthorInput>;
}

export interface GerneUpdateManyWithoutAuthorsInput {
  create?: Maybe<
    GerneCreateWithoutAuthorsInput[] | GerneCreateWithoutAuthorsInput
  >;
  delete?: Maybe<GerneWhereUniqueInput[] | GerneWhereUniqueInput>;
  connect?: Maybe<GerneWhereUniqueInput[] | GerneWhereUniqueInput>;
  set?: Maybe<GerneWhereUniqueInput[] | GerneWhereUniqueInput>;
  disconnect?: Maybe<GerneWhereUniqueInput[] | GerneWhereUniqueInput>;
  update?: Maybe<
    | GerneUpdateWithWhereUniqueWithoutAuthorsInput[]
    | GerneUpdateWithWhereUniqueWithoutAuthorsInput
  >;
  upsert?: Maybe<
    | GerneUpsertWithWhereUniqueWithoutAuthorsInput[]
    | GerneUpsertWithWhereUniqueWithoutAuthorsInput
  >;
  deleteMany?: Maybe<GerneScalarWhereInput[] | GerneScalarWhereInput>;
  updateMany?: Maybe<
    GerneUpdateManyWithWhereNestedInput[] | GerneUpdateManyWithWhereNestedInput
  >;
}

export interface GerneUpdateWithWhereUniqueWithoutAuthorsInput {
  where: GerneWhereUniqueInput;
  data: GerneUpdateWithoutAuthorsDataInput;
}

export interface GerneUpdateWithoutAuthorsDataInput {
  term?: Maybe<String>;
  books?: Maybe<BookUpdateManyWithoutGernesInput>;
}

export interface BookUpdateManyWithoutGernesInput {
  create?: Maybe<BookCreateWithoutGernesInput[] | BookCreateWithoutGernesInput>;
  delete?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  set?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  disconnect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  update?: Maybe<
    | BookUpdateWithWhereUniqueWithoutGernesInput[]
    | BookUpdateWithWhereUniqueWithoutGernesInput
  >;
  upsert?: Maybe<
    | BookUpsertWithWhereUniqueWithoutGernesInput[]
    | BookUpsertWithWhereUniqueWithoutGernesInput
  >;
  deleteMany?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
  updateMany?: Maybe<
    BookUpdateManyWithWhereNestedInput[] | BookUpdateManyWithWhereNestedInput
  >;
}

export interface BookUpdateWithWhereUniqueWithoutGernesInput {
  where: BookWhereUniqueInput;
  data: BookUpdateWithoutGernesDataInput;
}

export interface BookUpdateWithoutGernesDataInput {
  title?: Maybe<String>;
  author?: Maybe<AuthorUpdateOneRequiredWithoutBooksInput>;
  covorImage?: Maybe<String>;
  description?: Maybe<String>;
  comments?: Maybe<CommentUpdateManyWithoutBookInput>;
  ISBN?: Maybe<String>;
  wantCount?: Maybe<Int>;
  readingCount?: Maybe<Int>;
  readCount?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  pages?: Maybe<Int>;
  avgRatings?: Maybe<Int>;
}

export interface AuthorUpdateOneRequiredWithoutBooksInput {
  create?: Maybe<AuthorCreateWithoutBooksInput>;
  update?: Maybe<AuthorUpdateWithoutBooksDataInput>;
  upsert?: Maybe<AuthorUpsertWithoutBooksInput>;
  connect?: Maybe<AuthorWhereUniqueInput>;
}

export interface AuthorUpdateWithoutBooksDataInput {
  name?: Maybe<String>;
  Born?: Maybe<DateTimeInput>;
  Died?: Maybe<DateTimeInput>;
  gernes?: Maybe<GerneUpdateManyWithoutAuthorsInput>;
  description?: Maybe<String>;
  photos?: Maybe<AuthorUpdatephotosInput>;
  Quotes?: Maybe<QuoteUpdateManyWithoutAuthorInput>;
}

export interface AuthorUpdatephotosInput {
  set?: Maybe<String[] | String>;
}

export interface QuoteUpdateManyWithoutAuthorInput {
  create?: Maybe<
    QuoteCreateWithoutAuthorInput[] | QuoteCreateWithoutAuthorInput
  >;
  delete?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  connect?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  set?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  disconnect?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  update?: Maybe<
    | QuoteUpdateWithWhereUniqueWithoutAuthorInput[]
    | QuoteUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | QuoteUpsertWithWhereUniqueWithoutAuthorInput[]
    | QuoteUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<QuoteScalarWhereInput[] | QuoteScalarWhereInput>;
  updateMany?: Maybe<
    QuoteUpdateManyWithWhereNestedInput[] | QuoteUpdateManyWithWhereNestedInput
  >;
}

export interface QuoteUpdateWithWhereUniqueWithoutAuthorInput {
  where: QuoteWhereUniqueInput;
  data: QuoteUpdateWithoutAuthorDataInput;
}

export interface QuoteUpdateWithoutAuthorDataInput {
  term?: Maybe<String>;
  tags?: Maybe<TagUpdateManyWithoutQuotesInput>;
  likesCount?: Maybe<Int>;
}

export interface TagUpdateManyWithoutQuotesInput {
  create?: Maybe<TagCreateWithoutQuotesInput[] | TagCreateWithoutQuotesInput>;
  delete?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  set?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  disconnect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  update?: Maybe<
    | TagUpdateWithWhereUniqueWithoutQuotesInput[]
    | TagUpdateWithWhereUniqueWithoutQuotesInput
  >;
  upsert?: Maybe<
    | TagUpsertWithWhereUniqueWithoutQuotesInput[]
    | TagUpsertWithWhereUniqueWithoutQuotesInput
  >;
  deleteMany?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  updateMany?: Maybe<
    TagUpdateManyWithWhereNestedInput[] | TagUpdateManyWithWhereNestedInput
  >;
}

export interface TagUpdateWithWhereUniqueWithoutQuotesInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutQuotesDataInput;
}

export interface TagUpdateWithoutQuotesDataInput {
  term?: Maybe<String>;
}

export interface TagUpsertWithWhereUniqueWithoutQuotesInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutQuotesDataInput;
  create: TagCreateWithoutQuotesInput;
}

export interface TagScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  term?: Maybe<String>;
  term_not?: Maybe<String>;
  term_in?: Maybe<String[] | String>;
  term_not_in?: Maybe<String[] | String>;
  term_lt?: Maybe<String>;
  term_lte?: Maybe<String>;
  term_gt?: Maybe<String>;
  term_gte?: Maybe<String>;
  term_contains?: Maybe<String>;
  term_not_contains?: Maybe<String>;
  term_starts_with?: Maybe<String>;
  term_not_starts_with?: Maybe<String>;
  term_ends_with?: Maybe<String>;
  term_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  OR?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  NOT?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagUpdateManyDataInput {
  term?: Maybe<String>;
}

export interface QuoteUpsertWithWhereUniqueWithoutAuthorInput {
  where: QuoteWhereUniqueInput;
  update: QuoteUpdateWithoutAuthorDataInput;
  create: QuoteCreateWithoutAuthorInput;
}

export interface QuoteScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  term?: Maybe<String>;
  term_not?: Maybe<String>;
  term_in?: Maybe<String[] | String>;
  term_not_in?: Maybe<String[] | String>;
  term_lt?: Maybe<String>;
  term_lte?: Maybe<String>;
  term_gt?: Maybe<String>;
  term_gte?: Maybe<String>;
  term_contains?: Maybe<String>;
  term_not_contains?: Maybe<String>;
  term_starts_with?: Maybe<String>;
  term_not_starts_with?: Maybe<String>;
  term_ends_with?: Maybe<String>;
  term_not_ends_with?: Maybe<String>;
  likesCount?: Maybe<Int>;
  likesCount_not?: Maybe<Int>;
  likesCount_in?: Maybe<Int[] | Int>;
  likesCount_not_in?: Maybe<Int[] | Int>;
  likesCount_lt?: Maybe<Int>;
  likesCount_lte?: Maybe<Int>;
  likesCount_gt?: Maybe<Int>;
  likesCount_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<QuoteScalarWhereInput[] | QuoteScalarWhereInput>;
  OR?: Maybe<QuoteScalarWhereInput[] | QuoteScalarWhereInput>;
  NOT?: Maybe<QuoteScalarWhereInput[] | QuoteScalarWhereInput>;
}

export interface QuoteUpdateManyWithWhereNestedInput {
  where: QuoteScalarWhereInput;
  data: QuoteUpdateManyDataInput;
}

export interface QuoteUpdateManyDataInput {
  term?: Maybe<String>;
  likesCount?: Maybe<Int>;
}

export interface AuthorUpsertWithoutBooksInput {
  update: AuthorUpdateWithoutBooksDataInput;
  create: AuthorCreateWithoutBooksInput;
}

export interface CommentUpdateManyWithoutBookInput {
  create?: Maybe<
    CommentCreateWithoutBookInput[] | CommentCreateWithoutBookInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutBookInput[]
    | CommentUpdateWithWhereUniqueWithoutBookInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutBookInput[]
    | CommentUpsertWithWhereUniqueWithoutBookInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutBookInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutBookDataInput;
}

export interface CommentUpdateWithoutBookDataInput {
  user?: Maybe<UserUpdateOneWithoutBookCommentsInput>;
  text?: Maybe<String>;
}

export interface UserUpdateOneWithoutBookCommentsInput {
  create?: Maybe<UserCreateWithoutBookCommentsInput>;
  update?: Maybe<UserUpdateWithoutBookCommentsDataInput>;
  upsert?: Maybe<UserUpsertWithoutBookCommentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutBookCommentsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  username?: Maybe<String>;
  profile?: Maybe<ProfileUpdateOneWithoutUserInput>;
  isAdmin?: Maybe<Boolean>;
  RatingBooks?: Maybe<BookUpdateManyInput>;
  bookAvgRating?: Maybe<Float>;
  shelves?: Maybe<ShelfUpdateManyWithoutUserInput>;
  likeQuotes?: Maybe<QuoteUpdateManyInput>;
  displays?: Maybe<DisplayUpdateManyWithoutUserInput>;
}

export interface ProfileUpdateOneWithoutUserInput {
  create?: Maybe<ProfileCreateWithoutUserInput>;
  update?: Maybe<ProfileUpdateWithoutUserDataInput>;
  upsert?: Maybe<ProfileUpsertWithoutUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProfileWhereUniqueInput>;
}

export interface ProfileUpdateWithoutUserDataInput {
  age?: Maybe<Int>;
  gender?: Maybe<Gender>;
  bio?: Maybe<String>;
  interests?: Maybe<String>;
  favoriteBook?: Maybe<String>;
}

export interface ProfileUpsertWithoutUserInput {
  update: ProfileUpdateWithoutUserDataInput;
  create: ProfileCreateWithoutUserInput;
}

export interface BookUpdateManyInput {
  create?: Maybe<BookCreateInput[] | BookCreateInput>;
  update?: Maybe<
    | BookUpdateWithWhereUniqueNestedInput[]
    | BookUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | BookUpsertWithWhereUniqueNestedInput[]
    | BookUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  set?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  disconnect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  deleteMany?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
  updateMany?: Maybe<
    BookUpdateManyWithWhereNestedInput[] | BookUpdateManyWithWhereNestedInput
  >;
}

export interface BookUpdateWithWhereUniqueNestedInput {
  where: BookWhereUniqueInput;
  data: BookUpdateDataInput;
}

export interface BookUpdateDataInput {
  title?: Maybe<String>;
  author?: Maybe<AuthorUpdateOneRequiredWithoutBooksInput>;
  gernes?: Maybe<GerneUpdateManyWithoutBooksInput>;
  covorImage?: Maybe<String>;
  description?: Maybe<String>;
  comments?: Maybe<CommentUpdateManyWithoutBookInput>;
  ISBN?: Maybe<String>;
  wantCount?: Maybe<Int>;
  readingCount?: Maybe<Int>;
  readCount?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  pages?: Maybe<Int>;
  avgRatings?: Maybe<Int>;
}

export interface GerneUpdateManyWithoutBooksInput {
  create?: Maybe<GerneCreateWithoutBooksInput[] | GerneCreateWithoutBooksInput>;
  delete?: Maybe<GerneWhereUniqueInput[] | GerneWhereUniqueInput>;
  connect?: Maybe<GerneWhereUniqueInput[] | GerneWhereUniqueInput>;
  set?: Maybe<GerneWhereUniqueInput[] | GerneWhereUniqueInput>;
  disconnect?: Maybe<GerneWhereUniqueInput[] | GerneWhereUniqueInput>;
  update?: Maybe<
    | GerneUpdateWithWhereUniqueWithoutBooksInput[]
    | GerneUpdateWithWhereUniqueWithoutBooksInput
  >;
  upsert?: Maybe<
    | GerneUpsertWithWhereUniqueWithoutBooksInput[]
    | GerneUpsertWithWhereUniqueWithoutBooksInput
  >;
  deleteMany?: Maybe<GerneScalarWhereInput[] | GerneScalarWhereInput>;
  updateMany?: Maybe<
    GerneUpdateManyWithWhereNestedInput[] | GerneUpdateManyWithWhereNestedInput
  >;
}

export interface GerneUpdateWithWhereUniqueWithoutBooksInput {
  where: GerneWhereUniqueInput;
  data: GerneUpdateWithoutBooksDataInput;
}

export interface GerneUpdateWithoutBooksDataInput {
  term?: Maybe<String>;
  authors?: Maybe<AuthorUpdateManyWithoutGernesInput>;
}

export interface AuthorUpdateManyWithoutGernesInput {
  create?: Maybe<
    AuthorCreateWithoutGernesInput[] | AuthorCreateWithoutGernesInput
  >;
  delete?: Maybe<AuthorWhereUniqueInput[] | AuthorWhereUniqueInput>;
  connect?: Maybe<AuthorWhereUniqueInput[] | AuthorWhereUniqueInput>;
  set?: Maybe<AuthorWhereUniqueInput[] | AuthorWhereUniqueInput>;
  disconnect?: Maybe<AuthorWhereUniqueInput[] | AuthorWhereUniqueInput>;
  update?: Maybe<
    | AuthorUpdateWithWhereUniqueWithoutGernesInput[]
    | AuthorUpdateWithWhereUniqueWithoutGernesInput
  >;
  upsert?: Maybe<
    | AuthorUpsertWithWhereUniqueWithoutGernesInput[]
    | AuthorUpsertWithWhereUniqueWithoutGernesInput
  >;
  deleteMany?: Maybe<AuthorScalarWhereInput[] | AuthorScalarWhereInput>;
  updateMany?: Maybe<
    | AuthorUpdateManyWithWhereNestedInput[]
    | AuthorUpdateManyWithWhereNestedInput
  >;
}

export interface AuthorUpdateWithWhereUniqueWithoutGernesInput {
  where: AuthorWhereUniqueInput;
  data: AuthorUpdateWithoutGernesDataInput;
}

export interface AuthorUpdateWithoutGernesDataInput {
  name?: Maybe<String>;
  Born?: Maybe<DateTimeInput>;
  Died?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  photos?: Maybe<AuthorUpdatephotosInput>;
  books?: Maybe<BookUpdateManyWithoutAuthorInput>;
  Quotes?: Maybe<QuoteUpdateManyWithoutAuthorInput>;
}

export interface BookUpdateManyWithoutAuthorInput {
  create?: Maybe<BookCreateWithoutAuthorInput[] | BookCreateWithoutAuthorInput>;
  delete?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  connect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  set?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  disconnect?: Maybe<BookWhereUniqueInput[] | BookWhereUniqueInput>;
  update?: Maybe<
    | BookUpdateWithWhereUniqueWithoutAuthorInput[]
    | BookUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | BookUpsertWithWhereUniqueWithoutAuthorInput[]
    | BookUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
  updateMany?: Maybe<
    BookUpdateManyWithWhereNestedInput[] | BookUpdateManyWithWhereNestedInput
  >;
}

export interface BookUpdateWithWhereUniqueWithoutAuthorInput {
  where: BookWhereUniqueInput;
  data: BookUpdateWithoutAuthorDataInput;
}

export interface BookUpdateWithoutAuthorDataInput {
  title?: Maybe<String>;
  gernes?: Maybe<GerneUpdateManyWithoutBooksInput>;
  covorImage?: Maybe<String>;
  description?: Maybe<String>;
  comments?: Maybe<CommentUpdateManyWithoutBookInput>;
  ISBN?: Maybe<String>;
  wantCount?: Maybe<Int>;
  readingCount?: Maybe<Int>;
  readCount?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  pages?: Maybe<Int>;
  avgRatings?: Maybe<Int>;
}

export interface BookUpsertWithWhereUniqueWithoutAuthorInput {
  where: BookWhereUniqueInput;
  update: BookUpdateWithoutAuthorDataInput;
  create: BookCreateWithoutAuthorInput;
}

export interface BookScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  covorImage?: Maybe<String>;
  covorImage_not?: Maybe<String>;
  covorImage_in?: Maybe<String[] | String>;
  covorImage_not_in?: Maybe<String[] | String>;
  covorImage_lt?: Maybe<String>;
  covorImage_lte?: Maybe<String>;
  covorImage_gt?: Maybe<String>;
  covorImage_gte?: Maybe<String>;
  covorImage_contains?: Maybe<String>;
  covorImage_not_contains?: Maybe<String>;
  covorImage_starts_with?: Maybe<String>;
  covorImage_not_starts_with?: Maybe<String>;
  covorImage_ends_with?: Maybe<String>;
  covorImage_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  ISBN?: Maybe<String>;
  ISBN_not?: Maybe<String>;
  ISBN_in?: Maybe<String[] | String>;
  ISBN_not_in?: Maybe<String[] | String>;
  ISBN_lt?: Maybe<String>;
  ISBN_lte?: Maybe<String>;
  ISBN_gt?: Maybe<String>;
  ISBN_gte?: Maybe<String>;
  ISBN_contains?: Maybe<String>;
  ISBN_not_contains?: Maybe<String>;
  ISBN_starts_with?: Maybe<String>;
  ISBN_not_starts_with?: Maybe<String>;
  ISBN_ends_with?: Maybe<String>;
  ISBN_not_ends_with?: Maybe<String>;
  wantCount?: Maybe<Int>;
  wantCount_not?: Maybe<Int>;
  wantCount_in?: Maybe<Int[] | Int>;
  wantCount_not_in?: Maybe<Int[] | Int>;
  wantCount_lt?: Maybe<Int>;
  wantCount_lte?: Maybe<Int>;
  wantCount_gt?: Maybe<Int>;
  wantCount_gte?: Maybe<Int>;
  readingCount?: Maybe<Int>;
  readingCount_not?: Maybe<Int>;
  readingCount_in?: Maybe<Int[] | Int>;
  readingCount_not_in?: Maybe<Int[] | Int>;
  readingCount_lt?: Maybe<Int>;
  readingCount_lte?: Maybe<Int>;
  readingCount_gt?: Maybe<Int>;
  readingCount_gte?: Maybe<Int>;
  readCount?: Maybe<Int>;
  readCount_not?: Maybe<Int>;
  readCount_in?: Maybe<Int[] | Int>;
  readCount_not_in?: Maybe<Int[] | Int>;
  readCount_lt?: Maybe<Int>;
  readCount_lte?: Maybe<Int>;
  readCount_gt?: Maybe<Int>;
  readCount_gte?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  avgRating_not?: Maybe<Float>;
  avgRating_in?: Maybe<Float[] | Float>;
  avgRating_not_in?: Maybe<Float[] | Float>;
  avgRating_lt?: Maybe<Float>;
  avgRating_lte?: Maybe<Float>;
  avgRating_gt?: Maybe<Float>;
  avgRating_gte?: Maybe<Float>;
  pages?: Maybe<Int>;
  pages_not?: Maybe<Int>;
  pages_in?: Maybe<Int[] | Int>;
  pages_not_in?: Maybe<Int[] | Int>;
  pages_lt?: Maybe<Int>;
  pages_lte?: Maybe<Int>;
  pages_gt?: Maybe<Int>;
  pages_gte?: Maybe<Int>;
  avgRatings?: Maybe<Int>;
  avgRatings_not?: Maybe<Int>;
  avgRatings_in?: Maybe<Int[] | Int>;
  avgRatings_not_in?: Maybe<Int[] | Int>;
  avgRatings_lt?: Maybe<Int>;
  avgRatings_lte?: Maybe<Int>;
  avgRatings_gt?: Maybe<Int>;
  avgRatings_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
  OR?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
  NOT?: Maybe<BookScalarWhereInput[] | BookScalarWhereInput>;
}

export interface BookUpdateManyWithWhereNestedInput {
  where: BookScalarWhereInput;
  data: BookUpdateManyDataInput;
}

export interface BookUpdateManyDataInput {
  title?: Maybe<String>;
  covorImage?: Maybe<String>;
  description?: Maybe<String>;
  ISBN?: Maybe<String>;
  wantCount?: Maybe<Int>;
  readingCount?: Maybe<Int>;
  readCount?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  pages?: Maybe<Int>;
  avgRatings?: Maybe<Int>;
}

export interface AuthorUpsertWithWhereUniqueWithoutGernesInput {
  where: AuthorWhereUniqueInput;
  update: AuthorUpdateWithoutGernesDataInput;
  create: AuthorCreateWithoutGernesInput;
}

export interface AuthorScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  Born?: Maybe<DateTimeInput>;
  Born_not?: Maybe<DateTimeInput>;
  Born_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  Born_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  Born_lt?: Maybe<DateTimeInput>;
  Born_lte?: Maybe<DateTimeInput>;
  Born_gt?: Maybe<DateTimeInput>;
  Born_gte?: Maybe<DateTimeInput>;
  Died?: Maybe<DateTimeInput>;
  Died_not?: Maybe<DateTimeInput>;
  Died_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  Died_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  Died_lt?: Maybe<DateTimeInput>;
  Died_lte?: Maybe<DateTimeInput>;
  Died_gt?: Maybe<DateTimeInput>;
  Died_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AuthorScalarWhereInput[] | AuthorScalarWhereInput>;
  OR?: Maybe<AuthorScalarWhereInput[] | AuthorScalarWhereInput>;
  NOT?: Maybe<AuthorScalarWhereInput[] | AuthorScalarWhereInput>;
}

export interface AuthorUpdateManyWithWhereNestedInput {
  where: AuthorScalarWhereInput;
  data: AuthorUpdateManyDataInput;
}

export interface AuthorUpdateManyDataInput {
  name?: Maybe<String>;
  Born?: Maybe<DateTimeInput>;
  Died?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  photos?: Maybe<AuthorUpdatephotosInput>;
}

export interface GerneUpsertWithWhereUniqueWithoutBooksInput {
  where: GerneWhereUniqueInput;
  update: GerneUpdateWithoutBooksDataInput;
  create: GerneCreateWithoutBooksInput;
}

export interface GerneScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  term?: Maybe<String>;
  term_not?: Maybe<String>;
  term_in?: Maybe<String[] | String>;
  term_not_in?: Maybe<String[] | String>;
  term_lt?: Maybe<String>;
  term_lte?: Maybe<String>;
  term_gt?: Maybe<String>;
  term_gte?: Maybe<String>;
  term_contains?: Maybe<String>;
  term_not_contains?: Maybe<String>;
  term_starts_with?: Maybe<String>;
  term_not_starts_with?: Maybe<String>;
  term_ends_with?: Maybe<String>;
  term_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<GerneScalarWhereInput[] | GerneScalarWhereInput>;
  OR?: Maybe<GerneScalarWhereInput[] | GerneScalarWhereInput>;
  NOT?: Maybe<GerneScalarWhereInput[] | GerneScalarWhereInput>;
}

export interface GerneUpdateManyWithWhereNestedInput {
  where: GerneScalarWhereInput;
  data: GerneUpdateManyDataInput;
}

export interface GerneUpdateManyDataInput {
  term?: Maybe<String>;
}

export interface BookUpsertWithWhereUniqueNestedInput {
  where: BookWhereUniqueInput;
  update: BookUpdateDataInput;
  create: BookCreateInput;
}

export interface ShelfUpdateManyWithoutUserInput {
  create?: Maybe<ShelfCreateWithoutUserInput[] | ShelfCreateWithoutUserInput>;
  delete?: Maybe<ShelfWhereUniqueInput[] | ShelfWhereUniqueInput>;
  connect?: Maybe<ShelfWhereUniqueInput[] | ShelfWhereUniqueInput>;
  set?: Maybe<ShelfWhereUniqueInput[] | ShelfWhereUniqueInput>;
  disconnect?: Maybe<ShelfWhereUniqueInput[] | ShelfWhereUniqueInput>;
  update?: Maybe<
    | ShelfUpdateWithWhereUniqueWithoutUserInput[]
    | ShelfUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ShelfUpsertWithWhereUniqueWithoutUserInput[]
    | ShelfUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<ShelfScalarWhereInput[] | ShelfScalarWhereInput>;
  updateMany?: Maybe<
    ShelfUpdateManyWithWhereNestedInput[] | ShelfUpdateManyWithWhereNestedInput
  >;
}

export interface ShelfUpdateWithWhereUniqueWithoutUserInput {
  where: ShelfWhereUniqueInput;
  data: ShelfUpdateWithoutUserDataInput;
}

export interface ShelfUpdateWithoutUserDataInput {
  name?: Maybe<String>;
  displays?: Maybe<DisplayUpdateManyWithoutShelvesInput>;
}

export interface DisplayUpdateManyWithoutShelvesInput {
  create?: Maybe<
    DisplayCreateWithoutShelvesInput[] | DisplayCreateWithoutShelvesInput
  >;
  delete?: Maybe<DisplayWhereUniqueInput[] | DisplayWhereUniqueInput>;
  connect?: Maybe<DisplayWhereUniqueInput[] | DisplayWhereUniqueInput>;
  set?: Maybe<DisplayWhereUniqueInput[] | DisplayWhereUniqueInput>;
  disconnect?: Maybe<DisplayWhereUniqueInput[] | DisplayWhereUniqueInput>;
  update?: Maybe<
    | DisplayUpdateWithWhereUniqueWithoutShelvesInput[]
    | DisplayUpdateWithWhereUniqueWithoutShelvesInput
  >;
  upsert?: Maybe<
    | DisplayUpsertWithWhereUniqueWithoutShelvesInput[]
    | DisplayUpsertWithWhereUniqueWithoutShelvesInput
  >;
  deleteMany?: Maybe<DisplayScalarWhereInput[] | DisplayScalarWhereInput>;
}

export interface DisplayUpdateWithWhereUniqueWithoutShelvesInput {
  where: DisplayWhereUniqueInput;
  data: DisplayUpdateWithoutShelvesDataInput;
}

export interface DisplayUpdateWithoutShelvesDataInput {
  user?: Maybe<UserUpdateOneWithoutDisplaysInput>;
  book?: Maybe<BookUpdateOneInput>;
}

export interface UserUpdateOneWithoutDisplaysInput {
  create?: Maybe<UserCreateWithoutDisplaysInput>;
  update?: Maybe<UserUpdateWithoutDisplaysDataInput>;
  upsert?: Maybe<UserUpsertWithoutDisplaysInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutDisplaysDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  username?: Maybe<String>;
  profile?: Maybe<ProfileUpdateOneWithoutUserInput>;
  isAdmin?: Maybe<Boolean>;
  RatingBooks?: Maybe<BookUpdateManyInput>;
  bookAvgRating?: Maybe<Float>;
  bookComments?: Maybe<CommentUpdateManyWithoutUserInput>;
  shelves?: Maybe<ShelfUpdateManyWithoutUserInput>;
  likeQuotes?: Maybe<QuoteUpdateManyInput>;
}

export interface CommentUpdateManyWithoutUserInput {
  create?: Maybe<
    CommentCreateWithoutUserInput[] | CommentCreateWithoutUserInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutUserInput[]
    | CommentUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutUserInput[]
    | CommentUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutUserDataInput;
}

export interface CommentUpdateWithoutUserDataInput {
  Book?: Maybe<BookUpdateOneWithoutCommentsInput>;
  text?: Maybe<String>;
}

export interface BookUpdateOneWithoutCommentsInput {
  create?: Maybe<BookCreateWithoutCommentsInput>;
  update?: Maybe<BookUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<BookUpsertWithoutCommentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BookWhereUniqueInput>;
}

export interface BookUpdateWithoutCommentsDataInput {
  title?: Maybe<String>;
  author?: Maybe<AuthorUpdateOneRequiredWithoutBooksInput>;
  gernes?: Maybe<GerneUpdateManyWithoutBooksInput>;
  covorImage?: Maybe<String>;
  description?: Maybe<String>;
  ISBN?: Maybe<String>;
  wantCount?: Maybe<Int>;
  readingCount?: Maybe<Int>;
  readCount?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  pages?: Maybe<Int>;
  avgRatings?: Maybe<Int>;
}

export interface BookUpsertWithoutCommentsInput {
  update: BookUpdateWithoutCommentsDataInput;
  create: BookCreateWithoutCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutUserInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutUserDataInput;
  create: CommentCreateWithoutUserInput;
}

export interface CommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  OR?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  NOT?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface CommentUpdateManyDataInput {
  text?: Maybe<String>;
}

export interface QuoteUpdateManyInput {
  create?: Maybe<QuoteCreateInput[] | QuoteCreateInput>;
  update?: Maybe<
    | QuoteUpdateWithWhereUniqueNestedInput[]
    | QuoteUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuoteUpsertWithWhereUniqueNestedInput[]
    | QuoteUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  connect?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  set?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  disconnect?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  deleteMany?: Maybe<QuoteScalarWhereInput[] | QuoteScalarWhereInput>;
  updateMany?: Maybe<
    QuoteUpdateManyWithWhereNestedInput[] | QuoteUpdateManyWithWhereNestedInput
  >;
}

export interface QuoteUpdateWithWhereUniqueNestedInput {
  where: QuoteWhereUniqueInput;
  data: QuoteUpdateDataInput;
}

export interface QuoteUpdateDataInput {
  term?: Maybe<String>;
  author?: Maybe<AuthorUpdateOneWithoutQuotesInput>;
  tags?: Maybe<TagUpdateManyWithoutQuotesInput>;
  likesCount?: Maybe<Int>;
}

export interface AuthorUpdateOneWithoutQuotesInput {
  create?: Maybe<AuthorCreateWithoutQuotesInput>;
  update?: Maybe<AuthorUpdateWithoutQuotesDataInput>;
  upsert?: Maybe<AuthorUpsertWithoutQuotesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<AuthorWhereUniqueInput>;
}

export interface AuthorUpdateWithoutQuotesDataInput {
  name?: Maybe<String>;
  Born?: Maybe<DateTimeInput>;
  Died?: Maybe<DateTimeInput>;
  gernes?: Maybe<GerneUpdateManyWithoutAuthorsInput>;
  description?: Maybe<String>;
  photos?: Maybe<AuthorUpdatephotosInput>;
  books?: Maybe<BookUpdateManyWithoutAuthorInput>;
}

export interface AuthorUpsertWithoutQuotesInput {
  update: AuthorUpdateWithoutQuotesDataInput;
  create: AuthorCreateWithoutQuotesInput;
}

export interface QuoteUpsertWithWhereUniqueNestedInput {
  where: QuoteWhereUniqueInput;
  update: QuoteUpdateDataInput;
  create: QuoteCreateInput;
}

export interface UserUpsertWithoutDisplaysInput {
  update: UserUpdateWithoutDisplaysDataInput;
  create: UserCreateWithoutDisplaysInput;
}

export interface BookUpdateOneInput {
  create?: Maybe<BookCreateInput>;
  update?: Maybe<BookUpdateDataInput>;
  upsert?: Maybe<BookUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<BookWhereUniqueInput>;
}

export interface BookUpsertNestedInput {
  update: BookUpdateDataInput;
  create: BookCreateInput;
}

export interface DisplayUpsertWithWhereUniqueWithoutShelvesInput {
  where: DisplayWhereUniqueInput;
  update: DisplayUpdateWithoutShelvesDataInput;
  create: DisplayCreateWithoutShelvesInput;
}

export interface DisplayScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<DisplayScalarWhereInput[] | DisplayScalarWhereInput>;
  OR?: Maybe<DisplayScalarWhereInput[] | DisplayScalarWhereInput>;
  NOT?: Maybe<DisplayScalarWhereInput[] | DisplayScalarWhereInput>;
}

export interface ShelfUpsertWithWhereUniqueWithoutUserInput {
  where: ShelfWhereUniqueInput;
  update: ShelfUpdateWithoutUserDataInput;
  create: ShelfCreateWithoutUserInput;
}

export interface ShelfScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ShelfScalarWhereInput[] | ShelfScalarWhereInput>;
  OR?: Maybe<ShelfScalarWhereInput[] | ShelfScalarWhereInput>;
  NOT?: Maybe<ShelfScalarWhereInput[] | ShelfScalarWhereInput>;
}

export interface ShelfUpdateManyWithWhereNestedInput {
  where: ShelfScalarWhereInput;
  data: ShelfUpdateManyDataInput;
}

export interface ShelfUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface DisplayUpdateManyWithoutUserInput {
  create?: Maybe<
    DisplayCreateWithoutUserInput[] | DisplayCreateWithoutUserInput
  >;
  delete?: Maybe<DisplayWhereUniqueInput[] | DisplayWhereUniqueInput>;
  connect?: Maybe<DisplayWhereUniqueInput[] | DisplayWhereUniqueInput>;
  set?: Maybe<DisplayWhereUniqueInput[] | DisplayWhereUniqueInput>;
  disconnect?: Maybe<DisplayWhereUniqueInput[] | DisplayWhereUniqueInput>;
  update?: Maybe<
    | DisplayUpdateWithWhereUniqueWithoutUserInput[]
    | DisplayUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | DisplayUpsertWithWhereUniqueWithoutUserInput[]
    | DisplayUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<DisplayScalarWhereInput[] | DisplayScalarWhereInput>;
}

export interface DisplayUpdateWithWhereUniqueWithoutUserInput {
  where: DisplayWhereUniqueInput;
  data: DisplayUpdateWithoutUserDataInput;
}

export interface DisplayUpdateWithoutUserDataInput {
  book?: Maybe<BookUpdateOneInput>;
  shelves?: Maybe<ShelfUpdateManyWithoutDisplaysInput>;
}

export interface ShelfUpdateManyWithoutDisplaysInput {
  create?: Maybe<
    ShelfCreateWithoutDisplaysInput[] | ShelfCreateWithoutDisplaysInput
  >;
  delete?: Maybe<ShelfWhereUniqueInput[] | ShelfWhereUniqueInput>;
  connect?: Maybe<ShelfWhereUniqueInput[] | ShelfWhereUniqueInput>;
  set?: Maybe<ShelfWhereUniqueInput[] | ShelfWhereUniqueInput>;
  disconnect?: Maybe<ShelfWhereUniqueInput[] | ShelfWhereUniqueInput>;
  update?: Maybe<
    | ShelfUpdateWithWhereUniqueWithoutDisplaysInput[]
    | ShelfUpdateWithWhereUniqueWithoutDisplaysInput
  >;
  upsert?: Maybe<
    | ShelfUpsertWithWhereUniqueWithoutDisplaysInput[]
    | ShelfUpsertWithWhereUniqueWithoutDisplaysInput
  >;
  deleteMany?: Maybe<ShelfScalarWhereInput[] | ShelfScalarWhereInput>;
  updateMany?: Maybe<
    ShelfUpdateManyWithWhereNestedInput[] | ShelfUpdateManyWithWhereNestedInput
  >;
}

export interface ShelfUpdateWithWhereUniqueWithoutDisplaysInput {
  where: ShelfWhereUniqueInput;
  data: ShelfUpdateWithoutDisplaysDataInput;
}

export interface ShelfUpdateWithoutDisplaysDataInput {
  user?: Maybe<UserUpdateOneWithoutShelvesInput>;
  name?: Maybe<String>;
}

export interface UserUpdateOneWithoutShelvesInput {
  create?: Maybe<UserCreateWithoutShelvesInput>;
  update?: Maybe<UserUpdateWithoutShelvesDataInput>;
  upsert?: Maybe<UserUpsertWithoutShelvesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutShelvesDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  username?: Maybe<String>;
  profile?: Maybe<ProfileUpdateOneWithoutUserInput>;
  isAdmin?: Maybe<Boolean>;
  RatingBooks?: Maybe<BookUpdateManyInput>;
  bookAvgRating?: Maybe<Float>;
  bookComments?: Maybe<CommentUpdateManyWithoutUserInput>;
  likeQuotes?: Maybe<QuoteUpdateManyInput>;
  displays?: Maybe<DisplayUpdateManyWithoutUserInput>;
}

export interface UserUpsertWithoutShelvesInput {
  update: UserUpdateWithoutShelvesDataInput;
  create: UserCreateWithoutShelvesInput;
}

export interface ShelfUpsertWithWhereUniqueWithoutDisplaysInput {
  where: ShelfWhereUniqueInput;
  update: ShelfUpdateWithoutDisplaysDataInput;
  create: ShelfCreateWithoutDisplaysInput;
}

export interface DisplayUpsertWithWhereUniqueWithoutUserInput {
  where: DisplayWhereUniqueInput;
  update: DisplayUpdateWithoutUserDataInput;
  create: DisplayCreateWithoutUserInput;
}

export interface UserUpsertWithoutBookCommentsInput {
  update: UserUpdateWithoutBookCommentsDataInput;
  create: UserCreateWithoutBookCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutBookInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutBookDataInput;
  create: CommentCreateWithoutBookInput;
}

export interface BookUpsertWithWhereUniqueWithoutGernesInput {
  where: BookWhereUniqueInput;
  update: BookUpdateWithoutGernesDataInput;
  create: BookCreateWithoutGernesInput;
}

export interface GerneUpsertWithWhereUniqueWithoutAuthorsInput {
  where: GerneWhereUniqueInput;
  update: GerneUpdateWithoutAuthorsDataInput;
  create: GerneCreateWithoutAuthorsInput;
}

export interface AuthorUpdateManyMutationInput {
  name?: Maybe<String>;
  Born?: Maybe<DateTimeInput>;
  Died?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  photos?: Maybe<AuthorUpdatephotosInput>;
}

export interface BookUpdateInput {
  title?: Maybe<String>;
  author?: Maybe<AuthorUpdateOneRequiredWithoutBooksInput>;
  gernes?: Maybe<GerneUpdateManyWithoutBooksInput>;
  covorImage?: Maybe<String>;
  description?: Maybe<String>;
  comments?: Maybe<CommentUpdateManyWithoutBookInput>;
  ISBN?: Maybe<String>;
  wantCount?: Maybe<Int>;
  readingCount?: Maybe<Int>;
  readCount?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  pages?: Maybe<Int>;
  avgRatings?: Maybe<Int>;
}

export interface BookUpdateManyMutationInput {
  title?: Maybe<String>;
  covorImage?: Maybe<String>;
  description?: Maybe<String>;
  ISBN?: Maybe<String>;
  wantCount?: Maybe<Int>;
  readingCount?: Maybe<Int>;
  readCount?: Maybe<Int>;
  avgRating?: Maybe<Float>;
  pages?: Maybe<Int>;
  avgRatings?: Maybe<Int>;
}

export interface CommentCreateInput {
  id?: Maybe<ID_Input>;
  Book?: Maybe<BookCreateOneWithoutCommentsInput>;
  user?: Maybe<UserCreateOneWithoutBookCommentsInput>;
  text: String;
}

export interface CommentUpdateInput {
  Book?: Maybe<BookUpdateOneWithoutCommentsInput>;
  user?: Maybe<UserUpdateOneWithoutBookCommentsInput>;
  text?: Maybe<String>;
}

export interface CommentUpdateManyMutationInput {
  text?: Maybe<String>;
}

export interface DisplayCreateInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutDisplaysInput>;
  book?: Maybe<BookCreateOneInput>;
  shelves?: Maybe<ShelfCreateManyWithoutDisplaysInput>;
}

export interface DisplayUpdateInput {
  user?: Maybe<UserUpdateOneWithoutDisplaysInput>;
  book?: Maybe<BookUpdateOneInput>;
  shelves?: Maybe<ShelfUpdateManyWithoutDisplaysInput>;
}

export interface GerneCreateInput {
  id?: Maybe<ID_Input>;
  term: String;
  books?: Maybe<BookCreateManyWithoutGernesInput>;
  authors?: Maybe<AuthorCreateManyWithoutGernesInput>;
}

export interface GerneUpdateInput {
  term?: Maybe<String>;
  books?: Maybe<BookUpdateManyWithoutGernesInput>;
  authors?: Maybe<AuthorUpdateManyWithoutGernesInput>;
}

export interface GerneUpdateManyMutationInput {
  term?: Maybe<String>;
}

export interface ProfileCreateInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutProfileInput>;
  age?: Maybe<Int>;
  gender: Gender;
  bio?: Maybe<String>;
  interests?: Maybe<String>;
  favoriteBook?: Maybe<String>;
}

export interface UserCreateOneWithoutProfileInput {
  create?: Maybe<UserCreateWithoutProfileInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutProfileInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  username: String;
  isAdmin?: Maybe<Boolean>;
  RatingBooks?: Maybe<BookCreateManyInput>;
  bookAvgRating?: Maybe<Float>;
  bookComments?: Maybe<CommentCreateManyWithoutUserInput>;
  shelves?: Maybe<ShelfCreateManyWithoutUserInput>;
  likeQuotes?: Maybe<QuoteCreateManyInput>;
  displays?: Maybe<DisplayCreateManyWithoutUserInput>;
}

export interface ProfileUpdateInput {
  user?: Maybe<UserUpdateOneWithoutProfileInput>;
  age?: Maybe<Int>;
  gender?: Maybe<Gender>;
  bio?: Maybe<String>;
  interests?: Maybe<String>;
  favoriteBook?: Maybe<String>;
}

export interface UserUpdateOneWithoutProfileInput {
  create?: Maybe<UserCreateWithoutProfileInput>;
  update?: Maybe<UserUpdateWithoutProfileDataInput>;
  upsert?: Maybe<UserUpsertWithoutProfileInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutProfileDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  username?: Maybe<String>;
  isAdmin?: Maybe<Boolean>;
  RatingBooks?: Maybe<BookUpdateManyInput>;
  bookAvgRating?: Maybe<Float>;
  bookComments?: Maybe<CommentUpdateManyWithoutUserInput>;
  shelves?: Maybe<ShelfUpdateManyWithoutUserInput>;
  likeQuotes?: Maybe<QuoteUpdateManyInput>;
  displays?: Maybe<DisplayUpdateManyWithoutUserInput>;
}

export interface UserUpsertWithoutProfileInput {
  update: UserUpdateWithoutProfileDataInput;
  create: UserCreateWithoutProfileInput;
}

export interface ProfileUpdateManyMutationInput {
  age?: Maybe<Int>;
  gender?: Maybe<Gender>;
  bio?: Maybe<String>;
  interests?: Maybe<String>;
  favoriteBook?: Maybe<String>;
}

export interface QuoteUpdateInput {
  term?: Maybe<String>;
  author?: Maybe<AuthorUpdateOneWithoutQuotesInput>;
  tags?: Maybe<TagUpdateManyWithoutQuotesInput>;
  likesCount?: Maybe<Int>;
}

export interface QuoteUpdateManyMutationInput {
  term?: Maybe<String>;
  likesCount?: Maybe<Int>;
}

export interface ShelfCreateInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutShelvesInput>;
  name: String;
  displays?: Maybe<DisplayCreateManyWithoutShelvesInput>;
}

export interface ShelfUpdateInput {
  user?: Maybe<UserUpdateOneWithoutShelvesInput>;
  name?: Maybe<String>;
  displays?: Maybe<DisplayUpdateManyWithoutShelvesInput>;
}

export interface ShelfUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface TagCreateInput {
  id?: Maybe<ID_Input>;
  quotes?: Maybe<QuoteCreateManyWithoutTagsInput>;
  term: String;
}

export interface QuoteCreateManyWithoutTagsInput {
  create?: Maybe<QuoteCreateWithoutTagsInput[] | QuoteCreateWithoutTagsInput>;
  connect?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
}

export interface QuoteCreateWithoutTagsInput {
  id?: Maybe<ID_Input>;
  term?: Maybe<String>;
  author?: Maybe<AuthorCreateOneWithoutQuotesInput>;
  likesCount?: Maybe<Int>;
}

export interface TagUpdateInput {
  quotes?: Maybe<QuoteUpdateManyWithoutTagsInput>;
  term?: Maybe<String>;
}

export interface QuoteUpdateManyWithoutTagsInput {
  create?: Maybe<QuoteCreateWithoutTagsInput[] | QuoteCreateWithoutTagsInput>;
  delete?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  connect?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  set?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  disconnect?: Maybe<QuoteWhereUniqueInput[] | QuoteWhereUniqueInput>;
  update?: Maybe<
    | QuoteUpdateWithWhereUniqueWithoutTagsInput[]
    | QuoteUpdateWithWhereUniqueWithoutTagsInput
  >;
  upsert?: Maybe<
    | QuoteUpsertWithWhereUniqueWithoutTagsInput[]
    | QuoteUpsertWithWhereUniqueWithoutTagsInput
  >;
  deleteMany?: Maybe<QuoteScalarWhereInput[] | QuoteScalarWhereInput>;
  updateMany?: Maybe<
    QuoteUpdateManyWithWhereNestedInput[] | QuoteUpdateManyWithWhereNestedInput
  >;
}

export interface QuoteUpdateWithWhereUniqueWithoutTagsInput {
  where: QuoteWhereUniqueInput;
  data: QuoteUpdateWithoutTagsDataInput;
}

export interface QuoteUpdateWithoutTagsDataInput {
  term?: Maybe<String>;
  author?: Maybe<AuthorUpdateOneWithoutQuotesInput>;
  likesCount?: Maybe<Int>;
}

export interface QuoteUpsertWithWhereUniqueWithoutTagsInput {
  where: QuoteWhereUniqueInput;
  update: QuoteUpdateWithoutTagsDataInput;
  create: QuoteCreateWithoutTagsInput;
}

export interface TagUpdateManyMutationInput {
  term?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  username: String;
  profile?: Maybe<ProfileCreateOneWithoutUserInput>;
  isAdmin?: Maybe<Boolean>;
  RatingBooks?: Maybe<BookCreateManyInput>;
  bookAvgRating?: Maybe<Float>;
  bookComments?: Maybe<CommentCreateManyWithoutUserInput>;
  shelves?: Maybe<ShelfCreateManyWithoutUserInput>;
  likeQuotes?: Maybe<QuoteCreateManyInput>;
  displays?: Maybe<DisplayCreateManyWithoutUserInput>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  username?: Maybe<String>;
  profile?: Maybe<ProfileUpdateOneWithoutUserInput>;
  isAdmin?: Maybe<Boolean>;
  RatingBooks?: Maybe<BookUpdateManyInput>;
  bookAvgRating?: Maybe<Float>;
  bookComments?: Maybe<CommentUpdateManyWithoutUserInput>;
  shelves?: Maybe<ShelfUpdateManyWithoutUserInput>;
  likeQuotes?: Maybe<QuoteUpdateManyInput>;
  displays?: Maybe<DisplayUpdateManyWithoutUserInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  username?: Maybe<String>;
  isAdmin?: Maybe<Boolean>;
  bookAvgRating?: Maybe<Float>;
}

export interface AuthorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AuthorWhereInput>;
  AND?: Maybe<AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput>;
  OR?: Maybe<AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput>;
  NOT?: Maybe<AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput>;
}

export interface BookSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BookWhereInput>;
  AND?: Maybe<BookSubscriptionWhereInput[] | BookSubscriptionWhereInput>;
  OR?: Maybe<BookSubscriptionWhereInput[] | BookSubscriptionWhereInput>;
  NOT?: Maybe<BookSubscriptionWhereInput[] | BookSubscriptionWhereInput>;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface DisplaySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DisplayWhereInput>;
  AND?: Maybe<DisplaySubscriptionWhereInput[] | DisplaySubscriptionWhereInput>;
  OR?: Maybe<DisplaySubscriptionWhereInput[] | DisplaySubscriptionWhereInput>;
  NOT?: Maybe<DisplaySubscriptionWhereInput[] | DisplaySubscriptionWhereInput>;
}

export interface GerneSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GerneWhereInput>;
  AND?: Maybe<GerneSubscriptionWhereInput[] | GerneSubscriptionWhereInput>;
  OR?: Maybe<GerneSubscriptionWhereInput[] | GerneSubscriptionWhereInput>;
  NOT?: Maybe<GerneSubscriptionWhereInput[] | GerneSubscriptionWhereInput>;
}

export interface ProfileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProfileWhereInput>;
  AND?: Maybe<ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput>;
  OR?: Maybe<ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput>;
  NOT?: Maybe<ProfileSubscriptionWhereInput[] | ProfileSubscriptionWhereInput>;
}

export interface QuoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuoteWhereInput>;
  AND?: Maybe<QuoteSubscriptionWhereInput[] | QuoteSubscriptionWhereInput>;
  OR?: Maybe<QuoteSubscriptionWhereInput[] | QuoteSubscriptionWhereInput>;
  NOT?: Maybe<QuoteSubscriptionWhereInput[] | QuoteSubscriptionWhereInput>;
}

export interface ShelfSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ShelfWhereInput>;
  AND?: Maybe<ShelfSubscriptionWhereInput[] | ShelfSubscriptionWhereInput>;
  OR?: Maybe<ShelfSubscriptionWhereInput[] | ShelfSubscriptionWhereInput>;
  NOT?: Maybe<ShelfSubscriptionWhereInput[] | ShelfSubscriptionWhereInput>;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TagWhereInput>;
  AND?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  OR?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  NOT?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Author {
  id: ID_Output;
  name: String;
  Born?: DateTimeOutput;
  Died?: DateTimeOutput;
  description?: String;
  photos: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AuthorPromise extends Promise<Author>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  Born: () => Promise<DateTimeOutput>;
  Died: () => Promise<DateTimeOutput>;
  gernes: <T = FragmentableArray<Gerne>>(args?: {
    where?: GerneWhereInput;
    orderBy?: GerneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  description: () => Promise<String>;
  photos: () => Promise<String[]>;
  books: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Quotes: <T = FragmentableArray<Quote>>(args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AuthorSubscription
  extends Promise<AsyncIterator<Author>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  Born: () => Promise<AsyncIterator<DateTimeOutput>>;
  Died: () => Promise<AsyncIterator<DateTimeOutput>>;
  gernes: <T = Promise<AsyncIterator<GerneSubscription>>>(args?: {
    where?: GerneWhereInput;
    orderBy?: GerneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  description: () => Promise<AsyncIterator<String>>;
  photos: () => Promise<AsyncIterator<String[]>>;
  books: <T = Promise<AsyncIterator<BookSubscription>>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Quotes: <T = Promise<AsyncIterator<QuoteSubscription>>>(args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AuthorNullablePromise
  extends Promise<Author | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  Born: () => Promise<DateTimeOutput>;
  Died: () => Promise<DateTimeOutput>;
  gernes: <T = FragmentableArray<Gerne>>(args?: {
    where?: GerneWhereInput;
    orderBy?: GerneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  description: () => Promise<String>;
  photos: () => Promise<String[]>;
  books: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  Quotes: <T = FragmentableArray<Quote>>(args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Gerne {
  id: ID_Output;
  term: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GernePromise extends Promise<Gerne>, Fragmentable {
  id: () => Promise<ID_Output>;
  term: () => Promise<String>;
  books: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  authors: <T = FragmentableArray<Author>>(args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GerneSubscription
  extends Promise<AsyncIterator<Gerne>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  term: () => Promise<AsyncIterator<String>>;
  books: <T = Promise<AsyncIterator<BookSubscription>>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  authors: <T = Promise<AsyncIterator<AuthorSubscription>>>(args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GerneNullablePromise
  extends Promise<Gerne | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  term: () => Promise<String>;
  books: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  authors: <T = FragmentableArray<Author>>(args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Book {
  id: ID_Output;
  title: String;
  covorImage: String;
  description: String;
  ISBN: String;
  wantCount: Int;
  readingCount: Int;
  readCount: Int;
  avgRating: Float;
  pages?: Int;
  avgRatings?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookPromise extends Promise<Book>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  author: <T = AuthorPromise>() => T;
  gernes: <T = FragmentableArray<Gerne>>(args?: {
    where?: GerneWhereInput;
    orderBy?: GerneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  covorImage: () => Promise<String>;
  description: () => Promise<String>;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ISBN: () => Promise<String>;
  wantCount: () => Promise<Int>;
  readingCount: () => Promise<Int>;
  readCount: () => Promise<Int>;
  avgRating: () => Promise<Float>;
  pages: () => Promise<Int>;
  avgRatings: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookSubscription
  extends Promise<AsyncIterator<Book>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  author: <T = AuthorSubscription>() => T;
  gernes: <T = Promise<AsyncIterator<GerneSubscription>>>(args?: {
    where?: GerneWhereInput;
    orderBy?: GerneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  covorImage: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ISBN: () => Promise<AsyncIterator<String>>;
  wantCount: () => Promise<AsyncIterator<Int>>;
  readingCount: () => Promise<AsyncIterator<Int>>;
  readCount: () => Promise<AsyncIterator<Int>>;
  avgRating: () => Promise<AsyncIterator<Float>>;
  pages: () => Promise<AsyncIterator<Int>>;
  avgRatings: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookNullablePromise
  extends Promise<Book | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  author: <T = AuthorPromise>() => T;
  gernes: <T = FragmentableArray<Gerne>>(args?: {
    where?: GerneWhereInput;
    orderBy?: GerneOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  covorImage: () => Promise<String>;
  description: () => Promise<String>;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  ISBN: () => Promise<String>;
  wantCount: () => Promise<Int>;
  readingCount: () => Promise<Int>;
  readCount: () => Promise<Int>;
  avgRating: () => Promise<Float>;
  pages: () => Promise<Int>;
  avgRatings: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Comment {
  id: ID_Output;
  text: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  Book: <T = BookPromise>() => T;
  user: <T = UserPromise>() => T;
  text: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  Book: <T = BookSubscription>() => T;
  user: <T = UserSubscription>() => T;
  text: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  Book: <T = BookPromise>() => T;
  user: <T = UserPromise>() => T;
  text: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface User {
  id: ID_Output;
  email: String;
  password: String;
  username: String;
  isAdmin?: Boolean;
  bookAvgRating?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  username: () => Promise<String>;
  profile: <T = ProfilePromise>() => T;
  isAdmin: () => Promise<Boolean>;
  RatingBooks: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookAvgRating: () => Promise<Float>;
  bookComments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shelves: <T = FragmentableArray<Shelf>>(args?: {
    where?: ShelfWhereInput;
    orderBy?: ShelfOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likeQuotes: <T = FragmentableArray<Quote>>(args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  displays: <T = FragmentableArray<Display>>(args?: {
    where?: DisplayWhereInput;
    orderBy?: DisplayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  profile: <T = ProfileSubscription>() => T;
  isAdmin: () => Promise<AsyncIterator<Boolean>>;
  RatingBooks: <T = Promise<AsyncIterator<BookSubscription>>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookAvgRating: () => Promise<AsyncIterator<Float>>;
  bookComments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shelves: <T = Promise<AsyncIterator<ShelfSubscription>>>(args?: {
    where?: ShelfWhereInput;
    orderBy?: ShelfOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likeQuotes: <T = Promise<AsyncIterator<QuoteSubscription>>>(args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  displays: <T = Promise<AsyncIterator<DisplaySubscription>>>(args?: {
    where?: DisplayWhereInput;
    orderBy?: DisplayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  username: () => Promise<String>;
  profile: <T = ProfilePromise>() => T;
  isAdmin: () => Promise<Boolean>;
  RatingBooks: <T = FragmentableArray<Book>>(args?: {
    where?: BookWhereInput;
    orderBy?: BookOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bookAvgRating: () => Promise<Float>;
  bookComments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  shelves: <T = FragmentableArray<Shelf>>(args?: {
    where?: ShelfWhereInput;
    orderBy?: ShelfOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likeQuotes: <T = FragmentableArray<Quote>>(args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  displays: <T = FragmentableArray<Display>>(args?: {
    where?: DisplayWhereInput;
    orderBy?: DisplayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Profile {
  id: ID_Output;
  age?: Int;
  gender: Gender;
  bio?: String;
  interests?: String;
  favoriteBook?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProfilePromise extends Promise<Profile>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  age: () => Promise<Int>;
  gender: () => Promise<Gender>;
  bio: () => Promise<String>;
  interests: () => Promise<String>;
  favoriteBook: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProfileSubscription
  extends Promise<AsyncIterator<Profile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  age: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  bio: () => Promise<AsyncIterator<String>>;
  interests: () => Promise<AsyncIterator<String>>;
  favoriteBook: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProfileNullablePromise
  extends Promise<Profile | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  age: () => Promise<Int>;
  gender: () => Promise<Gender>;
  bio: () => Promise<String>;
  interests: () => Promise<String>;
  favoriteBook: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Shelf {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ShelfPromise extends Promise<Shelf>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  name: () => Promise<String>;
  displays: <T = FragmentableArray<Display>>(args?: {
    where?: DisplayWhereInput;
    orderBy?: DisplayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ShelfSubscription
  extends Promise<AsyncIterator<Shelf>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  displays: <T = Promise<AsyncIterator<DisplaySubscription>>>(args?: {
    where?: DisplayWhereInput;
    orderBy?: DisplayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShelfNullablePromise
  extends Promise<Shelf | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  name: () => Promise<String>;
  displays: <T = FragmentableArray<Display>>(args?: {
    where?: DisplayWhereInput;
    orderBy?: DisplayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Display {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DisplayPromise extends Promise<Display>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  book: <T = BookPromise>() => T;
  shelves: <T = FragmentableArray<Shelf>>(args?: {
    where?: ShelfWhereInput;
    orderBy?: ShelfOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DisplaySubscription
  extends Promise<AsyncIterator<Display>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  book: <T = BookSubscription>() => T;
  shelves: <T = Promise<AsyncIterator<ShelfSubscription>>>(args?: {
    where?: ShelfWhereInput;
    orderBy?: ShelfOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DisplayNullablePromise
  extends Promise<Display | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  book: <T = BookPromise>() => T;
  shelves: <T = FragmentableArray<Shelf>>(args?: {
    where?: ShelfWhereInput;
    orderBy?: ShelfOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Quote {
  id: ID_Output;
  term?: String;
  likesCount?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface QuotePromise extends Promise<Quote>, Fragmentable {
  id: () => Promise<ID_Output>;
  term: () => Promise<String>;
  author: <T = AuthorPromise>() => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likesCount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface QuoteSubscription
  extends Promise<AsyncIterator<Quote>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  term: () => Promise<AsyncIterator<String>>;
  author: <T = AuthorSubscription>() => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likesCount: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface QuoteNullablePromise
  extends Promise<Quote | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  term: () => Promise<String>;
  author: <T = AuthorPromise>() => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likesCount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Tag {
  id: ID_Output;
  term: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  quotes: <T = FragmentableArray<Quote>>(args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  term: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quotes: <T = Promise<AsyncIterator<QuoteSubscription>>>(args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  term: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TagNullablePromise extends Promise<Tag | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  quotes: <T = FragmentableArray<Quote>>(args?: {
    where?: QuoteWhereInput;
    orderBy?: QuoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  term: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AuthorConnection {
  pageInfo: PageInfo;
  edges: AuthorEdge[];
}

export interface AuthorConnectionPromise
  extends Promise<AuthorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AuthorEdge>>() => T;
  aggregate: <T = AggregateAuthorPromise>() => T;
}

export interface AuthorConnectionSubscription
  extends Promise<AsyncIterator<AuthorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AuthorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAuthorSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AuthorEdge {
  node: Author;
  cursor: String;
}

export interface AuthorEdgePromise extends Promise<AuthorEdge>, Fragmentable {
  node: <T = AuthorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AuthorEdgeSubscription
  extends Promise<AsyncIterator<AuthorEdge>>,
    Fragmentable {
  node: <T = AuthorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAuthor {
  count: Int;
}

export interface AggregateAuthorPromise
  extends Promise<AggregateAuthor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAuthorSubscription
  extends Promise<AsyncIterator<AggregateAuthor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BookConnection {
  pageInfo: PageInfo;
  edges: BookEdge[];
}

export interface BookConnectionPromise
  extends Promise<BookConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BookEdge>>() => T;
  aggregate: <T = AggregateBookPromise>() => T;
}

export interface BookConnectionSubscription
  extends Promise<AsyncIterator<BookConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BookEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBookSubscription>() => T;
}

export interface BookEdge {
  node: Book;
  cursor: String;
}

export interface BookEdgePromise extends Promise<BookEdge>, Fragmentable {
  node: <T = BookPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BookEdgeSubscription
  extends Promise<AsyncIterator<BookEdge>>,
    Fragmentable {
  node: <T = BookSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBook {
  count: Int;
}

export interface AggregateBookPromise
  extends Promise<AggregateBook>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBookSubscription
  extends Promise<AsyncIterator<AggregateBook>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DisplayConnection {
  pageInfo: PageInfo;
  edges: DisplayEdge[];
}

export interface DisplayConnectionPromise
  extends Promise<DisplayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DisplayEdge>>() => T;
  aggregate: <T = AggregateDisplayPromise>() => T;
}

export interface DisplayConnectionSubscription
  extends Promise<AsyncIterator<DisplayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DisplayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDisplaySubscription>() => T;
}

export interface DisplayEdge {
  node: Display;
  cursor: String;
}

export interface DisplayEdgePromise extends Promise<DisplayEdge>, Fragmentable {
  node: <T = DisplayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DisplayEdgeSubscription
  extends Promise<AsyncIterator<DisplayEdge>>,
    Fragmentable {
  node: <T = DisplaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDisplay {
  count: Int;
}

export interface AggregateDisplayPromise
  extends Promise<AggregateDisplay>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDisplaySubscription
  extends Promise<AsyncIterator<AggregateDisplay>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GerneConnection {
  pageInfo: PageInfo;
  edges: GerneEdge[];
}

export interface GerneConnectionPromise
  extends Promise<GerneConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GerneEdge>>() => T;
  aggregate: <T = AggregateGernePromise>() => T;
}

export interface GerneConnectionSubscription
  extends Promise<AsyncIterator<GerneConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GerneEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGerneSubscription>() => T;
}

export interface GerneEdge {
  node: Gerne;
  cursor: String;
}

export interface GerneEdgePromise extends Promise<GerneEdge>, Fragmentable {
  node: <T = GernePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GerneEdgeSubscription
  extends Promise<AsyncIterator<GerneEdge>>,
    Fragmentable {
  node: <T = GerneSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGerne {
  count: Int;
}

export interface AggregateGernePromise
  extends Promise<AggregateGerne>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGerneSubscription
  extends Promise<AsyncIterator<AggregateGerne>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProfileConnection {
  pageInfo: PageInfo;
  edges: ProfileEdge[];
}

export interface ProfileConnectionPromise
  extends Promise<ProfileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProfileEdge>>() => T;
  aggregate: <T = AggregateProfilePromise>() => T;
}

export interface ProfileConnectionSubscription
  extends Promise<AsyncIterator<ProfileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProfileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProfileSubscription>() => T;
}

export interface ProfileEdge {
  node: Profile;
  cursor: String;
}

export interface ProfileEdgePromise extends Promise<ProfileEdge>, Fragmentable {
  node: <T = ProfilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProfileEdgeSubscription
  extends Promise<AsyncIterator<ProfileEdge>>,
    Fragmentable {
  node: <T = ProfileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProfile {
  count: Int;
}

export interface AggregateProfilePromise
  extends Promise<AggregateProfile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProfileSubscription
  extends Promise<AsyncIterator<AggregateProfile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuoteConnection {
  pageInfo: PageInfo;
  edges: QuoteEdge[];
}

export interface QuoteConnectionPromise
  extends Promise<QuoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuoteEdge>>() => T;
  aggregate: <T = AggregateQuotePromise>() => T;
}

export interface QuoteConnectionSubscription
  extends Promise<AsyncIterator<QuoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuoteSubscription>() => T;
}

export interface QuoteEdge {
  node: Quote;
  cursor: String;
}

export interface QuoteEdgePromise extends Promise<QuoteEdge>, Fragmentable {
  node: <T = QuotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuoteEdgeSubscription
  extends Promise<AsyncIterator<QuoteEdge>>,
    Fragmentable {
  node: <T = QuoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuote {
  count: Int;
}

export interface AggregateQuotePromise
  extends Promise<AggregateQuote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuoteSubscription
  extends Promise<AsyncIterator<AggregateQuote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShelfConnection {
  pageInfo: PageInfo;
  edges: ShelfEdge[];
}

export interface ShelfConnectionPromise
  extends Promise<ShelfConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShelfEdge>>() => T;
  aggregate: <T = AggregateShelfPromise>() => T;
}

export interface ShelfConnectionSubscription
  extends Promise<AsyncIterator<ShelfConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShelfEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShelfSubscription>() => T;
}

export interface ShelfEdge {
  node: Shelf;
  cursor: String;
}

export interface ShelfEdgePromise extends Promise<ShelfEdge>, Fragmentable {
  node: <T = ShelfPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShelfEdgeSubscription
  extends Promise<AsyncIterator<ShelfEdge>>,
    Fragmentable {
  node: <T = ShelfSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateShelf {
  count: Int;
}

export interface AggregateShelfPromise
  extends Promise<AggregateShelf>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShelfSubscription
  extends Promise<AsyncIterator<AggregateShelf>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AuthorSubscriptionPayload {
  mutation: MutationType;
  node: Author;
  updatedFields: String[];
  previousValues: AuthorPreviousValues;
}

export interface AuthorSubscriptionPayloadPromise
  extends Promise<AuthorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AuthorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AuthorPreviousValuesPromise>() => T;
}

export interface AuthorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AuthorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AuthorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AuthorPreviousValuesSubscription>() => T;
}

export interface AuthorPreviousValues {
  id: ID_Output;
  name: String;
  Born?: DateTimeOutput;
  Died?: DateTimeOutput;
  description?: String;
  photos: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AuthorPreviousValuesPromise
  extends Promise<AuthorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  Born: () => Promise<DateTimeOutput>;
  Died: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  photos: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AuthorPreviousValuesSubscription
  extends Promise<AsyncIterator<AuthorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  Born: () => Promise<AsyncIterator<DateTimeOutput>>;
  Died: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  photos: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BookSubscriptionPayload {
  mutation: MutationType;
  node: Book;
  updatedFields: String[];
  previousValues: BookPreviousValues;
}

export interface BookSubscriptionPayloadPromise
  extends Promise<BookSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BookPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BookPreviousValuesPromise>() => T;
}

export interface BookSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BookSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BookSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BookPreviousValuesSubscription>() => T;
}

export interface BookPreviousValues {
  id: ID_Output;
  title: String;
  covorImage: String;
  description: String;
  ISBN: String;
  wantCount: Int;
  readingCount: Int;
  readCount: Int;
  avgRating: Float;
  pages?: Int;
  avgRatings?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface BookPreviousValuesPromise
  extends Promise<BookPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  covorImage: () => Promise<String>;
  description: () => Promise<String>;
  ISBN: () => Promise<String>;
  wantCount: () => Promise<Int>;
  readingCount: () => Promise<Int>;
  readCount: () => Promise<Int>;
  avgRating: () => Promise<Float>;
  pages: () => Promise<Int>;
  avgRatings: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BookPreviousValuesSubscription
  extends Promise<AsyncIterator<BookPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  covorImage: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  ISBN: () => Promise<AsyncIterator<String>>;
  wantCount: () => Promise<AsyncIterator<Int>>;
  readingCount: () => Promise<AsyncIterator<Int>>;
  readCount: () => Promise<AsyncIterator<Int>>;
  avgRating: () => Promise<AsyncIterator<Float>>;
  pages: () => Promise<AsyncIterator<Int>>;
  avgRatings: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  text: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DisplaySubscriptionPayload {
  mutation: MutationType;
  node: Display;
  updatedFields: String[];
  previousValues: DisplayPreviousValues;
}

export interface DisplaySubscriptionPayloadPromise
  extends Promise<DisplaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DisplayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DisplayPreviousValuesPromise>() => T;
}

export interface DisplaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DisplaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DisplaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DisplayPreviousValuesSubscription>() => T;
}

export interface DisplayPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface DisplayPreviousValuesPromise
  extends Promise<DisplayPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface DisplayPreviousValuesSubscription
  extends Promise<AsyncIterator<DisplayPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GerneSubscriptionPayload {
  mutation: MutationType;
  node: Gerne;
  updatedFields: String[];
  previousValues: GernePreviousValues;
}

export interface GerneSubscriptionPayloadPromise
  extends Promise<GerneSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GernePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GernePreviousValuesPromise>() => T;
}

export interface GerneSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GerneSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GerneSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GernePreviousValuesSubscription>() => T;
}

export interface GernePreviousValues {
  id: ID_Output;
  term: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GernePreviousValuesPromise
  extends Promise<GernePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  term: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GernePreviousValuesSubscription
  extends Promise<AsyncIterator<GernePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  term: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProfileSubscriptionPayload {
  mutation: MutationType;
  node: Profile;
  updatedFields: String[];
  previousValues: ProfilePreviousValues;
}

export interface ProfileSubscriptionPayloadPromise
  extends Promise<ProfileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProfilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProfilePreviousValuesPromise>() => T;
}

export interface ProfileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProfileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProfileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProfilePreviousValuesSubscription>() => T;
}

export interface ProfilePreviousValues {
  id: ID_Output;
  age?: Int;
  gender: Gender;
  bio?: String;
  interests?: String;
  favoriteBook?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProfilePreviousValuesPromise
  extends Promise<ProfilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  age: () => Promise<Int>;
  gender: () => Promise<Gender>;
  bio: () => Promise<String>;
  interests: () => Promise<String>;
  favoriteBook: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProfilePreviousValuesSubscription
  extends Promise<AsyncIterator<ProfilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  age: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  bio: () => Promise<AsyncIterator<String>>;
  interests: () => Promise<AsyncIterator<String>>;
  favoriteBook: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface QuoteSubscriptionPayload {
  mutation: MutationType;
  node: Quote;
  updatedFields: String[];
  previousValues: QuotePreviousValues;
}

export interface QuoteSubscriptionPayloadPromise
  extends Promise<QuoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuotePreviousValuesPromise>() => T;
}

export interface QuoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuotePreviousValuesSubscription>() => T;
}

export interface QuotePreviousValues {
  id: ID_Output;
  term?: String;
  likesCount?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface QuotePreviousValuesPromise
  extends Promise<QuotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  term: () => Promise<String>;
  likesCount: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface QuotePreviousValuesSubscription
  extends Promise<AsyncIterator<QuotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  term: () => Promise<AsyncIterator<String>>;
  likesCount: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ShelfSubscriptionPayload {
  mutation: MutationType;
  node: Shelf;
  updatedFields: String[];
  previousValues: ShelfPreviousValues;
}

export interface ShelfSubscriptionPayloadPromise
  extends Promise<ShelfSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShelfPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShelfPreviousValuesPromise>() => T;
}

export interface ShelfSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShelfSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShelfSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShelfPreviousValuesSubscription>() => T;
}

export interface ShelfPreviousValues {
  id: ID_Output;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ShelfPreviousValuesPromise
  extends Promise<ShelfPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ShelfPreviousValuesSubscription
  extends Promise<AsyncIterator<ShelfPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  term: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  term: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  term: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  username: String;
  isAdmin?: Boolean;
  bookAvgRating?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  username: () => Promise<String>;
  isAdmin: () => Promise<Boolean>;
  bookAvgRating: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  username: () => Promise<AsyncIterator<String>>;
  isAdmin: () => Promise<AsyncIterator<Boolean>>;
  bookAvgRating: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Book",
    embedded: false
  },
  {
    name: "Author",
    embedded: false
  },
  {
    name: "Gerne",
    embedded: false
  },
  {
    name: "Quote",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Display",
    embedded: false
  },
  {
    name: "Shelf",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Profile",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://goodreads-server-fcb22bfb7f.herokuapp.com`
});
export const prisma = new Prisma();
